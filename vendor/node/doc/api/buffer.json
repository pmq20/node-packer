{
  "source": "doc/api/buffer.md",
  "modules": [
    {
      "textRaw": "Buffer",
      "name": "buffer",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>Prior to the introduction of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> in ECMAScript 2015 (ES6), the\nJavaScript language had no mechanism for reading or manipulating streams\nof binary data. The <code>Buffer</code> class was introduced as part of the Node.js\nAPI to make it possible to interact with octet streams in the context of things\nlike TCP streams and file system operations.</p>\n<p>Now that <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> has been added in ES6, the <code>Buffer</code> class implements the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a> API in a manner that is more optimized and suitable for Node.js&#39;\nuse cases.</p>\n<p>Instances of the <code>Buffer</code> class are similar to arrays of integers but\ncorrespond to fixed-sized, raw memory allocations outside the V8 heap.\nThe size of the <code>Buffer</code> is established when it is created and cannot be\nresized.</p>\n<p>The <code>Buffer</code> class is a global within Node.js, making it unlikely that one\nwould need to ever use <code>require(&#39;buffer&#39;).Buffer</code>.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">// Creates a zero-filled Buffer of length 10.\nconst buf1 = Buffer.alloc(10);\n\n// Creates a Buffer of length 10, filled with 0x1.\nconst buf2 = Buffer.alloc(10, 1);\n\n// Creates an uninitialized buffer of length 10.\n// This is faster than calling Buffer.alloc() but the returned\n// Buffer instance might contain old data that needs to be\n// overwritten using either fill() or write().\nconst buf3 = Buffer.allocUnsafe(10);\n\n// Creates a Buffer containing [0x1, 0x2, 0x3].\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// Creates a Buffer containing ASCII bytes [0x74, 0x65, 0x73, 0x74].\nconst buf5 = Buffer.from(&#39;test&#39;);\n\n// Creates a Buffer containing UTF-8 bytes [0x74, 0xc3, 0xa9, 0x73, 0x74].\nconst buf6 = Buffer.from(&#39;tést&#39;, &#39;utf8&#39;);\n</code></pre>\n",
      "modules": [
        {
          "textRaw": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`",
          "name": "`buffer.from()`,_`buffer.alloc()`,_and_`buffer.allocunsafe()`",
          "desc": "<p>In versions of Node.js prior to v6, <code>Buffer</code> instances were created using the\n<code>Buffer</code> constructor function, which allocates the returned <code>Buffer</code>\ndifferently based on what arguments are provided:</p>\n<ul>\n<li>Passing a number as the first argument to <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>),\nallocates a new <code>Buffer</code> object of the specified size. The memory allocated\nfor such <code>Buffer</code> instances is <em>not</em> initialized and <em>can contain sensitive\ndata</em>. Such <code>Buffer</code> instances <em>must</em> be initialized <em>manually</em> by using either\n<a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> or by writing to the <code>Buffer</code> completely. While\nthis behavior is <em>intentional</em> to improve performance, development experience\nhas demonstrated that a more explicit distinction is required between creating\na fast-but-uninitialized <code>Buffer</code> versus creating a slower-but-safer <code>Buffer</code>.</li>\n<li>Passing a string, array, or <code>Buffer</code> as the first argument copies the\npassed object&#39;s data into the <code>Buffer</code>.</li>\n<li>Passing an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> returns a <code>Buffer</code> that shares allocated memory with\nthe given <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>.</li>\n</ul>\n<p>Because the behavior of <code>new Buffer()</code> changes significantly based on the type\nof value passed as the first argument, applications that do not properly\nvalidate the input arguments passed to <code>new Buffer()</code>, or that fail to\nappropriately initialize newly allocated <code>Buffer</code> content, can inadvertently\nintroduce security and reliability issues into their code.</p>\n<p>To make the creation of <code>Buffer</code> instances more reliable and less error prone,\nthe various forms of the <code>new Buffer()</code> constructor have been <strong>deprecated</strong>\nand replaced by separate <code>Buffer.from()</code>, <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a>, and\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> methods.</p>\n<p><em>Developers should migrate all existing uses of the <code>new Buffer()</code> constructors\nto one of these new APIs.</em></p>\n<ul>\n<li><a href=\"#buffer_class_method_buffer_from_array\"><code>Buffer.from(array)</code></a> returns a new <code>Buffer</code> containing a <em>copy</em> of the provided\noctets.</li>\n<li><a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a>\nreturns a new <code>Buffer</code> that <em>shares</em> the same allocated memory as the given\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>.</li>\n<li><a href=\"#buffer_class_method_buffer_from_buffer\"><code>Buffer.from(buffer)</code></a> returns a new <code>Buffer</code> containing a <em>copy</em> of the\ncontents of the given <code>Buffer</code>.</li>\n<li><a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a> returns a new <code>Buffer</code>\ncontaining a <em>copy</em> of the provided string.</li>\n<li><a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc(size[, fill[, encoding]])</code></a> returns a &quot;filled&quot;\n<code>Buffer</code> instance of the specified size. This method can be significantly\nslower than <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe(size)</code></a> but ensures\nthat newly created <code>Buffer</code> instances never contain old and potentially\nsensitive data.</li>\n<li><a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe(size)</code></a> and\n<a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow(size)</code></a> each return a\nnew <code>Buffer</code> of the specified <code>size</code> whose content <em>must</em> be initialized\nusing either <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> or written to completely.</li>\n</ul>\n<p><code>Buffer</code> instances returned by <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> <em>may</em> be allocated off\na shared internal memory pool if <code>size</code> is less than or equal to half\n<a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a>. Instances returned by <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a> <em>never</em>\nuse the shared internal memory pool.</p>\n",
          "modules": [
            {
              "textRaw": "The `--zero-fill-buffers` command line option",
              "name": "the_`--zero-fill-buffers`_command_line_option",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "desc": "<p>Node.js can be started using the <code>--zero-fill-buffers</code> command line option to\nforce all newly allocated <code>Buffer</code> instances created using either\n<code>new Buffer(size)</code>, <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>, <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a> or\n<code>new SlowBuffer(size)</code> to be <em>automatically zero-filled</em> upon creation. Use of\nthis flag <em>changes the default behavior</em> of these methods and <em>can have a significant\nimpact</em> on performance. Use of the <code>--zero-fill-buffers</code> option is recommended\nonly when necessary to enforce that newly allocated <code>Buffer</code> instances cannot\ncontain potentially sensitive data.</p>\n<p>Example:</p>\n<pre><code class=\"lang-txt\">$ node --zero-fill-buffers\n&gt; Buffer.allocUnsafe(5);\n&lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n",
              "type": "module",
              "displayName": "The `--zero-fill-buffers` command line option"
            },
            {
              "textRaw": "What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` \"unsafe\"?",
              "name": "what_makes_`buffer.allocunsafe()`_and_`buffer.allocunsafeslow()`_\"unsafe\"?",
              "desc": "<p>When calling <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> and <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a>, the\nsegment of allocated memory is <em>uninitialized</em> (it is not zeroed-out). While\nthis design makes the allocation of memory quite fast, the allocated segment of\nmemory might contain old data that is potentially sensitive. Using a <code>Buffer</code>\ncreated by <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> without <em>completely</em> overwriting the memory\ncan allow this old data to be leaked when the <code>Buffer</code> memory is read.</p>\n<p>While there are clear performance advantages to using <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>,\nextra care <em>must</em> be taken in order to avoid introducing security\nvulnerabilities into an application.</p>\n",
              "type": "module",
              "displayName": "What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` \"unsafe\"?"
            }
          ],
          "type": "module",
          "displayName": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`"
        },
        {
          "textRaw": "Buffers and Character Encodings",
          "name": "buffers_and_character_encodings",
          "desc": "<p><code>Buffer</code> instances are commonly used to represent sequences of encoded characters\nsuch as UTF-8, UCS2, Base64 or even Hex-encoded data. It is possible to\nconvert back and forth between <code>Buffer</code> instances and ordinary JavaScript strings\nby using an explicit character encoding.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;hello world&#39;, &#39;ascii&#39;);\n\n// Prints: 68656c6c6f20776f726c64\nconsole.log(buf.toString(&#39;hex&#39;));\n\n// Prints: aGVsbG8gd29ybGQ=\nconsole.log(buf.toString(&#39;base64&#39;));\n</code></pre>\n<p>The character encodings currently supported by Node.js include:</p>\n<ul>\n<li><p><code>&#39;ascii&#39;</code> - for 7-bit ASCII data only. This encoding is fast and will strip\nthe high bit if set.</p>\n</li>\n<li><p><code>&#39;utf8&#39;</code> - Multibyte encoded Unicode characters. Many web pages and other\ndocument formats use UTF-8.</p>\n</li>\n<li><p><code>&#39;utf16le&#39;</code> - 2 or 4 bytes, little-endian encoded Unicode characters.\nSurrogate pairs (U+10000 to U+10FFFF) are supported.</p>\n</li>\n<li><p><code>&#39;ucs2&#39;</code> - Alias of <code>&#39;utf16le&#39;</code>.</p>\n</li>\n<li><p><code>&#39;base64&#39;</code> - Base64 encoding. When creating a <code>Buffer</code> from a string,\nthis encoding will also correctly accept &quot;URL and Filename Safe Alphabet&quot; as\nspecified in <a href=\"https://tools.ietf.org/html/rfc4648#section-5\">RFC4648, Section 5</a>.</p>\n</li>\n<li><p><code>&#39;latin1&#39;</code> - A way of encoding the <code>Buffer</code> into a one-byte encoded string\n(as defined by the IANA in <a href=\"https://tools.ietf.org/html/rfc1345\">RFC1345</a>,\npage 63, to be the Latin-1 supplement block and C0/C1 control codes).</p>\n</li>\n<li><p><code>&#39;binary&#39;</code> - Alias for <code>&#39;latin1&#39;</code>.</p>\n</li>\n<li><p><code>&#39;hex&#39;</code> - Encode each byte as two hexadecimal characters.</p>\n</li>\n</ul>\n<p><em>Note</em>: Today&#39;s browsers follow the <a href=\"https://encoding.spec.whatwg.org/\">WHATWG spec</a> which aliases both &#39;latin1&#39; and\nISO-8859-1 to win-1252. This means that while doing something like <code>http.get()</code>,\nif the returned charset is one of those listed in the WHATWG spec it&#39;s possible\nthat the server actually returned win-1252-encoded data, and using <code>&#39;latin1&#39;</code>\nencoding may incorrectly decode the characters.</p>\n",
          "type": "module",
          "displayName": "Buffers and Character Encodings"
        },
        {
          "textRaw": "Buffers and TypedArray",
          "name": "buffers_and_typedarray",
          "desc": "<p><code>Buffer</code> instances are also <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a> instances. However, there are subtle\nincompatibilities with the TypedArray specification in ECMAScript 2015.\nFor example, while <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice\"><code>ArrayBuffer#slice()</code></a> creates a copy of the slice, the\nimplementation of <a href=\"#buffer_buf_slice_start_end\"><code>Buffer#slice()</code></a> creates a view over the\nexisting <code>Buffer</code> without copying, making <a href=\"#buffer_buf_slice_start_end\"><code>Buffer#slice()</code></a> far\nmore efficient.</p>\n<p>It is also possible to create new <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instances from a <code>Buffer</code> with\nthe following caveats:</p>\n<ol>\n<li><p>The <code>Buffer</code> object&#39;s memory is copied to the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>, not shared.</p>\n</li>\n<li><p>The <code>Buffer</code> object&#39;s memory is interpreted as an array of distinct\nelements, and not as a byte array of the target type. That is,\n<code>new Uint32Array(Buffer.from([1, 2, 3, 4]))</code> creates a 4-element <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array\"><code>Uint32Array</code></a>\nwith elements <code>[1, 2, 3, 4]</code>, not a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array\"><code>Uint32Array</code></a> with a single element\n<code>[0x1020304]</code> or <code>[0x4030201]</code>.</p>\n</li>\n</ol>\n<p>It is possible to create a new <code>Buffer</code> that shares the same allocated memory as\na <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance by using the TypeArray object&#39;s <code>.buffer</code> property.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Copies the contents of `arr`\nconst buf1 = Buffer.from(arr);\n\n// Shares memory with `arr`\nconst buf2 = Buffer.from(arr.buffer);\n\n// Prints: &lt;Buffer 88 a0&gt;\nconsole.log(buf1);\n\n// Prints: &lt;Buffer 88 13 a0 0f&gt;\nconsole.log(buf2);\n\narr[1] = 6000;\n\n// Prints: &lt;Buffer 88 a0&gt;\nconsole.log(buf1);\n\n// Prints: &lt;Buffer 88 13 70 17&gt;\nconsole.log(buf2);\n</code></pre>\n<p>Note that when creating a <code>Buffer</code> using a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>&#39;s <code>.buffer</code>, it is\npossible to use only a portion of the underlying <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> by passing in\n<code>byteOffset</code> and <code>length</code> parameters.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(20);\nconst buf = Buffer.from(arr.buffer, 0, 16);\n\n// Prints: 16\nconsole.log(buf.length);\n</code></pre>\n<p>The <code>Buffer.from()</code> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from\"><code>TypedArray.from()</code></a> have different signatures and\nimplementations. Specifically, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> variants accept a second\nargument that is a mapping function that is invoked on every element of the\ntyped array:</p>\n<ul>\n<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>\n</ul>\n<p>The <code>Buffer.from()</code> method, however, does not support the use of a mapping\nfunction:</p>\n<ul>\n<li><a href=\"#buffer_class_method_buffer_from_array\"><code>Buffer.from(array)</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_buffer\"><code>Buffer.from(buffer)</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a></li>\n</ul>\n",
          "type": "module",
          "displayName": "Buffers and TypedArray"
        },
        {
          "textRaw": "Buffers and ES6 iteration",
          "name": "buffers_and_es6_iteration",
          "desc": "<p><code>Buffer</code> instances can be iterated over using the ECMAScript 2015 (ES6) <code>for..of</code>\nsyntax.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3]);\n\n// Prints:\n//   1\n//   2\n//   3\nfor (const b of buf) {\n  console.log(b);\n}\n</code></pre>\n<p>Additionally, the <a href=\"#buffer_buf_values\"><code>buf.values()</code></a>, <a href=\"#buffer_buf_keys\"><code>buf.keys()</code></a>, and\n<a href=\"#buffer_buf_entries\"><code>buf.entries()</code></a> methods can be used to create iterators.</p>\n",
          "type": "module",
          "displayName": "Buffers and ES6 iteration"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Buffer",
          "type": "class",
          "name": "Buffer",
          "desc": "<p>The <code>Buffer</code> class is a global type for dealing with binary data directly.\nIt can be constructed in a variety of ways.</p>\n",
          "classMethods": [
            {
              "textRaw": "Class Method: Buffer.alloc(size[, fill[, encoding]])",
              "type": "classMethod",
              "name": "alloc",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {Integer} The desired length of the new `Buffer` ",
                      "name": "size",
                      "type": "Integer",
                      "desc": "The desired length of the new `Buffer`"
                    },
                    {
                      "textRaw": "`fill` {String | Buffer | Integer} A value to pre-fill the new `Buffer` with. **Default:** `0` ",
                      "name": "fill",
                      "type": "String | Buffer | Integer",
                      "desc": "A value to pre-fill the new `Buffer` with. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} If `fill` is a string, this is its encoding. **Default:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "If `fill` is a string, this is its encoding. **Default:** `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    },
                    {
                      "name": "fill",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the\n<code>Buffer</code> will be <em>zero-filled</em>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(5);\n\n// Prints: &lt;Buffer 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  If the <code>size</code> is larger than\n<a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a> or smaller than 0, a <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> will be thrown.\nA zero-length <code>Buffer</code> will be created if <code>size</code> is 0.</p>\n<p>If <code>fill</code> is specified, the allocated <code>Buffer</code> will be initialized by calling\n<a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(fill)</code></a>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(5, &#39;a&#39;);\n\n// Prints: &lt;Buffer 61 61 61 61 61&gt;\nconsole.log(buf);\n</code></pre>\n<p>If both <code>fill</code> and <code>encoding</code> are specified, the allocated <code>Buffer</code> will be\ninitialized by calling <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(fill, encoding)</code></a>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(11, &#39;aGVsbG8gd29ybGQ=&#39;, &#39;base64&#39;);\n\n// Prints: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;\nconsole.log(buf);\n</code></pre>\n<p>Calling <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> can be significantly slower than the alternative\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> but ensures that the newly created <code>Buffer</code> instance\ncontents will <em>never contain sensitive data</em>.</p>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.allocUnsafe(size)",
              "type": "classMethod",
              "name": "allocUnsafe",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {Integer} The desired length of the new `Buffer` ",
                      "name": "size",
                      "type": "Integer",
                      "desc": "The desired length of the new `Buffer`"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  If the <code>size</code> is larger than\n<a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a> or smaller than 0, a <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> will be thrown.\nA zero-length <code>Buffer</code> will be created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> instead to initialize\n<code>Buffer</code> instances to zeroes.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(10);\n\n// Prints: (contents may vary): &lt;Buffer a0 8b 28 3f 01 00 00 00 50 32&gt;\nconsole.log(buf);\n\nbuf.fill(0);\n\n// Prints: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n<p>Note that the <code>Buffer</code> module pre-allocates an internal <code>Buffer</code> instance of\nsize <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a> that is used as a pool for the fast allocation of new\n<code>Buffer</code> instances created using <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> and the deprecated\n<code>new Buffer(size)</code> constructor only when <code>size</code> is less than or equal to\n<code>Buffer.poolSize &gt;&gt; 1</code> (floor of <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a> divided by two).</p>\n<p>Use of this pre-allocated internal memory pool is a key difference between\ncalling <code>Buffer.alloc(size, fill)</code> vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>.\nSpecifically, <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal <code>Buffer</code>\npool, while <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the internal\n<code>Buffer</code> pool if <code>size</code> is less than or equal to half <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a>. The\ndifference is subtle but can be important when an application requires the\nadditional performance that <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> provides.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.allocUnsafeSlow(size)",
              "type": "classMethod",
              "name": "allocUnsafeSlow",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {Integer} The desired length of the new `Buffer` ",
                      "name": "size",
                      "type": "Integer",
                      "desc": "The desired length of the new `Buffer`"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  If the <code>size</code> is larger than\n<a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a> or smaller than 0, a <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> will be thrown.\nA zero-length <code>Buffer</code> will be created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> to initialize such\n<code>Buffer</code> instances to zeroes.</p>\n<p>When using <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> to allocate new <code>Buffer</code> instances,\nallocations under 4KB are, by default, sliced from a single pre-allocated\n<code>Buffer</code>. This allows applications to avoid the garbage collection overhead of\ncreating many individually allocated <code>Buffer</code> instances. This approach improves\nboth performance and memory usage by eliminating the need to track and cleanup as\nmany <code>Persistent</code> objects.</p>\n<p>However, in the case where a developer may need to retain a small chunk of\nmemory from a pool for an indeterminate amount of time, it may be appropriate\nto create an un-pooled <code>Buffer</code> instance using <code>Buffer.allocUnsafeSlow()</code> then\ncopy out the relevant bits.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">// Need to keep around a few small chunks of memory\nconst store = [];\n\nsocket.on(&#39;readable&#39;, () =&gt; {\n  const data = socket.read();\n\n  // Allocate for retained data\n  const sb = Buffer.allocUnsafeSlow(10);\n\n  // Copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n\n  store.push(sb);\n});\n</code></pre>\n<p>Use of <code>Buffer.allocUnsafeSlow()</code> should be used only as a last resort <em>after</em>\na developer has observed undue memory retention in their applications.</p>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.byteLength(string[, encoding])",
              "type": "classMethod",
              "name": "byteLength",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} The number of bytes contained within `string` ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "The number of bytes contained within `string`"
                  },
                  "params": [
                    {
                      "textRaw": "`string` {String | Buffer | TypedArray | DataView | ArrayBuffer} A value to calculate the length of ",
                      "name": "string",
                      "type": "String | Buffer | TypedArray | DataView | ArrayBuffer",
                      "desc": "A value to calculate the length of"
                    },
                    {
                      "textRaw": "`encoding` {String} If `string` is a string, this is its encoding. **Default:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "If `string` is a string, this is its encoding. **Default:** `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns the actual byte length of a string. This is not the same as\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length\"><code>String.prototype.length</code></a> since that returns the number of <em>characters</em> in\na string.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const str = &#39;\\u00bd + \\u00bc = \\u00be&#39;;\n\n// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes\nconsole.log(`${str}: ${str.length} characters, ` +\n            `${Buffer.byteLength(str, &#39;utf8&#39;)} bytes`);\n</code></pre>\n<p>When <code>string</code> is a <code>Buffer</code>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\"><code>DataView</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>, the\nactual byte length is returned.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.compare(buf1, buf2)",
              "type": "classMethod",
              "name": "compare",
              "meta": {
                "added": [
                  "v0.11.13"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`buf1` {Buffer} ",
                      "name": "buf1",
                      "type": "Buffer"
                    },
                    {
                      "textRaw": "`buf2` {Buffer} ",
                      "name": "buf2",
                      "type": "Buffer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf1"
                    },
                    {
                      "name": "buf2"
                    }
                  ]
                }
              ],
              "desc": "<p>Compares <code>buf1</code> to <code>buf2</code> typically for the purpose of sorting arrays of\n<code>Buffer</code> instances. This is equivalent to calling\n<a href=\"#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend\"><code>buf1.compare(buf2)</code></a>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;1234&#39;);\nconst buf2 = Buffer.from(&#39;0123&#39;);\nconst arr = [buf1, buf2];\n\n// Prints: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]\n// (This result is equal to: [buf2, buf1])\nconsole.log(arr.sort(Buffer.compare));\n</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.concat(list[, totalLength])",
              "type": "classMethod",
              "name": "concat",
              "meta": {
                "added": [
                  "v0.7.11"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} ",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`list` {Array} List of `Buffer` instances to concat ",
                      "name": "list",
                      "type": "Array",
                      "desc": "List of `Buffer` instances to concat"
                    },
                    {
                      "textRaw": "`totalLength` {Integer} Total length of the `Buffer` instances in `list` when concatenated ",
                      "name": "totalLength",
                      "type": "Integer",
                      "desc": "Total length of the `Buffer` instances in `list` when concatenated",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "list"
                    },
                    {
                      "name": "totalLength",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new <code>Buffer</code> which is the result of concatenating all the <code>Buffer</code>\ninstances in the <code>list</code> together.</p>\n<p>If the list has no items, or if the <code>totalLength</code> is 0, then a new zero-length\n<code>Buffer</code> is returned.</p>\n<p>If <code>totalLength</code> is not provided, it is calculated from the <code>Buffer</code> instances\nin <code>list</code>. This however causes an additional loop to be executed in order to\ncalculate the <code>totalLength</code>, so it is faster to provide the length explicitly if\nit is already known.</p>\n<p>Example: Create a single <code>Buffer</code> from a list of three <code>Buffer</code> instances</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.alloc(10);\nconst buf2 = Buffer.alloc(14);\nconst buf3 = Buffer.alloc(18);\nconst totalLength = buf1.length + buf2.length + buf3.length;\n\n// Prints: 42\nconsole.log(totalLength);\n\nconst bufA = Buffer.concat([buf1, buf2, buf3], totalLength);\n\n// Prints: &lt;Buffer 00 00 00 00 ...&gt;\nconsole.log(bufA);\n\n// Prints: 42\nconsole.log(bufA.length);\n</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(array)",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`array` {Array} ",
                      "name": "array",
                      "type": "Array"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "array"
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">// Creates a new Buffer containing ASCII bytes of the string &#39;buffer&#39;\nconst buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>array</code> is not an <code>Array</code>.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`arrayBuffer` {ArrayBuffer} The `.buffer` property of a [`TypedArray`] or [`ArrayBuffer`] ",
                      "name": "arrayBuffer",
                      "type": "ArrayBuffer",
                      "desc": "The `.buffer` property of a [`TypedArray`] or [`ArrayBuffer`]"
                    },
                    {
                      "textRaw": "`byteOffset` {Integer} Where to start copying from `arrayBuffer`. **Default:** `0` ",
                      "name": "byteOffset",
                      "type": "Integer",
                      "desc": "Where to start copying from `arrayBuffer`. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` {Integer} How many bytes to copy from `arrayBuffer`. **Default:** `arrayBuffer.length - byteOffset` ",
                      "name": "length",
                      "type": "Integer",
                      "desc": "How many bytes to copy from `arrayBuffer`. **Default:** `arrayBuffer.length - byteOffset`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "arrayBuffer"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "length",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>When passed a reference to the <code>.buffer</code> property of a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance,\nthe newly created <code>Buffer</code> will share the same allocated memory as the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`\nconst buf = Buffer.from(arr.buffer);\n\n// Prints: &lt;Buffer 88 13 a0 0f&gt;\nconsole.log(buf);\n\n// Changing the original Uint16Array changes the Buffer also\narr[1] = 6000;\n\n// Prints: &lt;Buffer 88 13 70 17&gt;\nconsole.log(buf);\n</code></pre>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const ab = new ArrayBuffer(10);\nconst buf = Buffer.from(ab, 0, 2);\n\n// Prints: 2\nconsole.log(buf.length);\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(buffer)",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`buffer` {Buffer} An existing `Buffer` to copy data from ",
                      "name": "buffer",
                      "type": "Buffer",
                      "desc": "An existing `Buffer` to copy data from"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;buffer&#39;);\nconst buf2 = Buffer.from(buf1);\n\nbuf1[0] = 0x61;\n\n// Prints: auffer\nconsole.log(buf1.toString());\n\n// Prints: buffer\nconsole.log(buf2.toString());\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>buffer</code> is not a <code>Buffer</code>.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(string[, encoding])",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`string` {String} A string to encode. ",
                      "name": "string",
                      "type": "String",
                      "desc": "A string to encode."
                    },
                    {
                      "textRaw": "`encoding` {String} The encoding of `string`. **Default:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "The encoding of `string`. **Default:** `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>string</code>. If\nprovided, the <code>encoding</code> parameter identifies the character encoding of <code>string</code>.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;this is a tést&#39;);\n\n// Prints: this is a tést\nconsole.log(buf1.toString());\n\n// Prints: this is a tC)st\nconsole.log(buf1.toString(&#39;ascii&#39;));\n\n\nconst buf2 = Buffer.from(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\n\n// Prints: this is a tést\nconsole.log(buf2.toString());\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>str</code> is not a string.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.isBuffer(obj)",
              "type": "classMethod",
              "name": "isBuffer",
              "meta": {
                "added": [
                  "v0.1.101"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Boolean} ",
                    "name": "return",
                    "type": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`obj` {Object} ",
                      "name": "obj",
                      "type": "Object"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "obj"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if <code>obj</code> is a <code>Buffer</code>, <code>false</code> otherwise.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.isEncoding(encoding)",
              "type": "classMethod",
              "name": "isEncoding",
              "meta": {
                "added": [
                  "v0.9.1"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Boolean} ",
                    "name": "return",
                    "type": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`encoding` {String} A character encoding name to check ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "A character encoding name to check"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if <code>encoding</code> contains a supported character encoding, or <code>false</code>\notherwise.</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "`poolSize` {Integer} **Default:** `8192` ",
              "type": "Integer",
              "name": "poolSize",
              "meta": {
                "added": [
                  "v0.11.3"
                ]
              },
              "desc": "<p>This is the number of bytes used to determine the size of pre-allocated, internal\n<code>Buffer</code> instances used for pooling. This value may be modified.</p>\n",
              "shortDesc": "**Default:** `8192`"
            },
            {
              "textRaw": "buf[index]",
              "name": "[index]",
              "meta": {
                "type": "property",
                "name": [
                  "index"
                ]
              },
              "desc": "<p>The index operator <code>[index]</code> can be used to get and set the octet at position\n<code>index</code> in <code>buf</code>. The values refer to individual bytes, so the legal value\nrange is between <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and <code>255</code> (decimal).</p>\n<p>Example: Copy an ASCII string into a <code>Buffer</code>, one byte at a time</p>\n<pre><code class=\"lang-js\">const str = &#39;Node.js&#39;;\nconst buf = Buffer.allocUnsafe(str.length);\n\nfor (let i = 0; i &lt; str.length ; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\n// Prints: Node.js\nconsole.log(buf.toString(&#39;ascii&#39;));\n</code></pre>\n"
            },
            {
              "textRaw": "`length` {Integer} ",
              "type": "Integer",
              "name": "length",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "desc": "<p>Returns the amount of memory allocated for <code>buf</code> in bytes. Note that this\ndoes not necessarily reflect the amount of &quot;usable&quot; data within <code>buf</code>.</p>\n<p>Example: Create a <code>Buffer</code> and write a shorter ASCII string to it</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(1234);\n\n// Prints: 1234\nconsole.log(buf.length);\n\nbuf.write(&#39;some string&#39;, 0, &#39;ascii&#39;);\n\n// Prints: 1234\nconsole.log(buf.length);\n</code></pre>\n<p>While the <code>length</code> property is not immutable, changing the value of <code>length</code>\ncan result in undefined and inconsistent behavior. Applications that wish to\nmodify the length of a <code>Buffer</code> should therefore treat <code>length</code> as read-only and\nuse <a href=\"#buffer_buf_slice_start_end\"><code>buf.slice()</code></a> to create a new <code>Buffer</code>.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">let buf = Buffer.allocUnsafe(10);\n\nbuf.write(&#39;abcdefghj&#39;, 0, &#39;ascii&#39;);\n\n// Prints: 10\nconsole.log(buf.length);\n\nbuf = buf.slice(0, 5);\n\n// Prints: 5\nconsole.log(buf.length);\n</code></pre>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])",
              "type": "method",
              "name": "compare",
              "meta": {
                "added": [
                  "v0.11.13"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`target` {Buffer} A `Buffer` to compare to ",
                      "name": "target",
                      "type": "Buffer",
                      "desc": "A `Buffer` to compare to"
                    },
                    {
                      "textRaw": "`targetStart` {Integer} The offset within `target` at which to begin comparison. **Default:** `0` ",
                      "name": "targetStart",
                      "type": "Integer",
                      "desc": "The offset within `target` at which to begin comparison. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`targetEnd` {Integer} The offset with `target` at which to end comparison (not inclusive). Ignored when `targetStart` is `undefined`. **Default:** `target.length` ",
                      "name": "targetEnd",
                      "type": "Integer",
                      "desc": "The offset with `target` at which to end comparison (not inclusive). Ignored when `targetStart` is `undefined`. **Default:** `target.length`",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceStart` {Integer} The offset within `buf` at which to begin comparison. Ignored when `targetStart` is `undefined`. **Default:** `0` ",
                      "name": "sourceStart",
                      "type": "Integer",
                      "desc": "The offset within `buf` at which to begin comparison. Ignored when `targetStart` is `undefined`. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceEnd` {Integer} The offset within `buf` at which to end comparison (not inclusive). Ignored when `targetStart` is `undefined`. **Default:** [`buf.length`] ",
                      "name": "sourceEnd",
                      "type": "Integer",
                      "desc": "The offset within `buf` at which to end comparison (not inclusive). Ignored when `targetStart` is `undefined`. **Default:** [`buf.length`]",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "target"
                    },
                    {
                      "name": "targetStart",
                      "optional": true
                    },
                    {
                      "name": "targetEnd",
                      "optional": true
                    },
                    {
                      "name": "sourceStart",
                      "optional": true
                    },
                    {
                      "name": "sourceEnd",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Compares <code>buf</code> with <code>target</code> and returns a number indicating whether <code>buf</code>\ncomes before, after, or is the same as <code>target</code> in sort order.\nComparison is based on the actual sequence of bytes in each <code>Buffer</code>.</p>\n<ul>\n<li><code>0</code> is returned if <code>target</code> is the same as <code>buf</code></li>\n<li><code>1</code> is returned if <code>target</code> should come <em>before</em> <code>buf</code> when sorted.</li>\n<li><code>-1</code> is returned if <code>target</code> should come <em>after</em> <code>buf</code> when sorted.</li>\n</ul>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;ABC&#39;);\nconst buf2 = Buffer.from(&#39;BCD&#39;);\nconst buf3 = Buffer.from(&#39;ABCD&#39;);\n\n// Prints: 0\nconsole.log(buf1.compare(buf1));\n\n// Prints: -1\nconsole.log(buf1.compare(buf2));\n\n// Prints: -1\nconsole.log(buf1.compare(buf3));\n\n// Prints: 1\nconsole.log(buf2.compare(buf1));\n\n// Prints: 1\nconsole.log(buf2.compare(buf3));\n\n// Prints: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]\n// (This result is equal to: [buf1, buf3, buf2])\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n</code></pre>\n<p>The optional <code>targetStart</code>, <code>targetEnd</code>, <code>sourceStart</code>, and <code>sourceEnd</code>\narguments can be used to limit the comparison to specific ranges within <code>target</code>\nand <code>buf</code> respectively.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\n// Prints: 0\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n\n// Prints: -1\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n\n// Prints: 1\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n</code></pre>\n<p>A <code>RangeError</code> will be thrown if: <code>targetStart &lt; 0</code>, <code>sourceStart &lt; 0</code>,\n<code>targetEnd &gt; target.byteLength</code> or <code>sourceEnd &gt; source.byteLength</code>.</p>\n"
            },
            {
              "textRaw": "buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])",
              "type": "method",
              "name": "copy",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} The number of bytes copied. ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "The number of bytes copied."
                  },
                  "params": [
                    {
                      "textRaw": "`target` {Buffer} A `Buffer` to copy into. ",
                      "name": "target",
                      "type": "Buffer",
                      "desc": "A `Buffer` to copy into."
                    },
                    {
                      "textRaw": "`targetStart` {Integer} The offset within `target` at which to begin copying to. **Default:** `0` ",
                      "name": "targetStart",
                      "type": "Integer",
                      "desc": "The offset within `target` at which to begin copying to. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceStart` {Integer} The offset within `buf` at which to begin copying from. Ignored when `targetStart` is `undefined`. **Default:** `0` ",
                      "name": "sourceStart",
                      "type": "Integer",
                      "desc": "The offset within `buf` at which to begin copying from. Ignored when `targetStart` is `undefined`. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceEnd` {Integer} The offset within `buf` at which to stop copying (not inclusive). Ignored when `sourceStart` is `undefined`. **Default:** [`buf.length`] ",
                      "name": "sourceEnd",
                      "type": "Integer",
                      "desc": "The offset within `buf` at which to stop copying (not inclusive). Ignored when `sourceStart` is `undefined`. **Default:** [`buf.length`]",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "target"
                    },
                    {
                      "name": "targetStart",
                      "optional": true
                    },
                    {
                      "name": "sourceStart",
                      "optional": true
                    },
                    {
                      "name": "sourceEnd",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Copies data from a region of <code>buf</code> to a region in <code>target</code> even if the <code>target</code>\nmemory region overlaps with <code>buf</code>.</p>\n<p>Example: Create two <code>Buffer</code> instances, <code>buf1</code> and <code>buf2</code>, and copy <code>buf1</code> from\nbyte 16 through byte 19 into <code>buf2</code>, starting at the 8th byte in <code>buf2</code></p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill(&#39;!&#39;);\n\nfor (let i = 0 ; i &lt; 26 ; i++) {\n  // 97 is the decimal ASCII value for &#39;a&#39;\n  buf1[i] = i + 97;\n}\n\nbuf1.copy(buf2, 8, 16, 20);\n\n// Prints: !!!!!!!!qrst!!!!!!!!!!!!!\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, 25));\n</code></pre>\n<p>Example: Create a single <code>Buffer</code> and copy data from one region to an\noverlapping region within the same <code>Buffer</code></p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0 ; i &lt; 26 ; i++) {\n  // 97 is the decimal ASCII value for &#39;a&#39;\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\n// Prints: efghijghijklmnopqrstuvwxyz\nconsole.log(buf.toString());\n</code></pre>\n"
            },
            {
              "textRaw": "buf.entries()",
              "type": "method",
              "name": "entries",
              "meta": {
                "added": [
                  "v1.1.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator} ",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> of <code>[index, byte]</code> pairs from the contents of\n<code>buf</code>.</p>\n<p>Example: Log the entire contents of a <code>Buffer</code></p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;buffer&#39;);\n\n// Prints:\n//   [0, 98]\n//   [1, 117]\n//   [2, 102]\n//   [3, 102]\n//   [4, 101]\n//   [5, 114]\nfor (const pair of buf.entries()) {\n  console.log(pair);\n}\n</code></pre>\n"
            },
            {
              "textRaw": "buf.equals(otherBuffer)",
              "type": "method",
              "name": "equals",
              "meta": {
                "added": [
                  "v0.11.13"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Boolean} ",
                    "name": "return",
                    "type": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`otherBuffer` {Buffer} A `Buffer` to compare to ",
                      "name": "otherBuffer",
                      "type": "Buffer",
                      "desc": "A `Buffer` to compare to"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "otherBuffer"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if both <code>buf</code> and <code>otherBuffer</code> have exactly the same bytes,\n<code>false</code> otherwise.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;ABC&#39;);\nconst buf2 = Buffer.from(&#39;414243&#39;, &#39;hex&#39;);\nconst buf3 = Buffer.from(&#39;ABCD&#39;);\n\n// Prints: true\nconsole.log(buf1.equals(buf2));\n\n// Prints: false\nconsole.log(buf1.equals(buf3));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.fill(value[, offset[, end]][, encoding])",
              "type": "method",
              "name": "fill",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf` ",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {String | Buffer | Integer} The value to fill `buf` with ",
                      "name": "value",
                      "type": "String | Buffer | Integer",
                      "desc": "The value to fill `buf` with"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start filling `buf`. **Default:** `0` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start filling `buf`. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {Integer} Where to stop filling `buf` (not inclusive). **Default:** [`buf.length`] ",
                      "name": "end",
                      "type": "Integer",
                      "desc": "Where to stop filling `buf` (not inclusive). **Default:** [`buf.length`]",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} If `value` is a string, this is its encoding. **Default:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "If `value` is a string, this is its encoding. **Default:** `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Fills <code>buf</code> with the specified <code>value</code>. If the <code>offset</code> and <code>end</code> are not given,\nthe entire <code>buf</code> will be filled. This is meant to be a small simplification to\nallow the creation and filling of a <code>Buffer</code> to be done on a single line.</p>\n<p>Example: Fill a <code>Buffer</code> with the ASCII character <code>&#39;h&#39;</code></p>\n<pre><code class=\"lang-js\">const b = Buffer.allocUnsafe(50).fill(&#39;h&#39;);\n\n// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\nconsole.log(b.toString());\n</code></pre>\n<p><code>value</code> is coerced to a <code>uint32</code> value if it is not a String or Integer.</p>\n<p>If the final write of a <code>fill()</code> operation falls on a multi-byte character,\nthen only the first bytes of that character that fit into <code>buf</code> are written.</p>\n<p>Example: Fill a <code>Buffer</code> with a two-byte character</p>\n<pre><code class=\"lang-js\">// Prints: &lt;Buffer c8 a2 c8&gt;\nconsole.log(Buffer.allocUnsafe(3).fill(&#39;\\u0222&#39;));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.indexOf(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "indexOf",
              "meta": {
                "added": [
                  "v1.5.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} The index of the first occurrence of `value` in `buf` or `-1` if `buf` does not contain `value` ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "The index of the first occurrence of `value` in `buf` or `-1` if `buf` does not contain `value`"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {String | Buffer | Integer} What to search for ",
                      "name": "value",
                      "type": "String | Buffer | Integer",
                      "desc": "What to search for"
                    },
                    {
                      "textRaw": "`byteOffset` {Integer} Where to begin searching in `buf`. **Default:** `0` ",
                      "name": "byteOffset",
                      "type": "Integer",
                      "desc": "Where to begin searching in `buf`. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} If `value` is a string, this is its encoding. **Default:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "If `value` is a string, this is its encoding. **Default:** `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>If <code>value</code> is:</p>\n<ul>\n<li>a string, <code>value</code> is interpreted according to the character encoding in\n<code>encoding</code>.</li>\n<li>a <code>Buffer</code>, <code>value</code> will be used in its entirety. To compare a partial\n<code>Buffer</code> use <a href=\"#buffer_buf_slice_start_end\"><code>buf.slice()</code></a>.</li>\n<li>a number, <code>value</code> will be interpreted as an unsigned 8-bit integer\nvalue between <code>0</code> and <code>255</code>.</li>\n</ul>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;this is a buffer&#39;);\n\n// Prints: 0\nconsole.log(buf.indexOf(&#39;this&#39;));\n\n// Prints: 2\nconsole.log(buf.indexOf(&#39;is&#39;));\n\n// Prints: 8\nconsole.log(buf.indexOf(Buffer.from(&#39;a buffer&#39;)));\n\n// Prints: 8\n// (97 is the decimal ASCII value for &#39;a&#39;)\nconsole.log(buf.indexOf(97));\n\n// Prints: -1\nconsole.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;)));\n\n// Prints: 8\nconsole.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));\n\n\nconst utf16Buffer = Buffer.from(&#39;\\u039a\\u0391\\u03a3\\u03a3\\u0395&#39;, &#39;ucs2&#39;);\n\n// Prints: 4\nconsole.log(utf16Buffer.indexOf(&#39;\\u03a3&#39;, 0, &#39;ucs2&#39;));\n\n// Prints: 6\nconsole.log(utf16Buffer.indexOf(&#39;\\u03a3&#39;, -4, &#39;ucs2&#39;));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.includes(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "includes",
              "meta": {
                "added": [
                  "v5.3.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Boolean} `true` if `value` was found in `buf`, `false` otherwise ",
                    "name": "return",
                    "type": "Boolean",
                    "desc": "`true` if `value` was found in `buf`, `false` otherwise"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {String | Buffer | Integer} What to search for ",
                      "name": "value",
                      "type": "String | Buffer | Integer",
                      "desc": "What to search for"
                    },
                    {
                      "textRaw": "`byteOffset` {Integer} Where to begin searching in `buf`. **Default:** `0` ",
                      "name": "byteOffset",
                      "type": "Integer",
                      "desc": "Where to begin searching in `buf`. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} If `value` is a string, this is its encoding. **Default:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "If `value` is a string, this is its encoding. **Default:** `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Equivalent to <a href=\"#buffer_buf_indexof_value_byteoffset_encoding\"><code>buf.indexOf() !== -1</code></a>.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;this is a buffer&#39;);\n\n// Prints: true\nconsole.log(buf.includes(&#39;this&#39;));\n\n// Prints: true\nconsole.log(buf.includes(&#39;is&#39;));\n\n// Prints: true\nconsole.log(buf.includes(Buffer.from(&#39;a buffer&#39;)));\n\n// Prints: true\n// (97 is the decimal ASCII value for &#39;a&#39;)\nconsole.log(buf.includes(97));\n\n// Prints: false\nconsole.log(buf.includes(Buffer.from(&#39;a buffer example&#39;)));\n\n// Prints: true\nconsole.log(buf.includes(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));\n\n// Prints: false\nconsole.log(buf.includes(&#39;this&#39;, 4));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.keys()",
              "type": "method",
              "name": "keys",
              "meta": {
                "added": [
                  "v1.1.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator} ",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> of <code>buf</code> keys (indices).</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;buffer&#39;);\n\n// Prints:\n//   0\n//   1\n//   2\n//   3\n//   4\n//   5\nfor (const key of buf.keys()) {\n  console.log(key);\n}\n</code></pre>\n"
            },
            {
              "textRaw": "buf.lastIndexOf(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "lastIndexOf",
              "meta": {
                "added": [
                  "v6.0.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} The index of the last occurrence of `value` in `buf` or `-1` if `buf` does not contain `value` ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "The index of the last occurrence of `value` in `buf` or `-1` if `buf` does not contain `value`"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {String | Buffer | Integer} What to search for ",
                      "name": "value",
                      "type": "String | Buffer | Integer",
                      "desc": "What to search for"
                    },
                    {
                      "textRaw": "`byteOffset` {Integer} Where to begin searching in `buf`. **Default:** [`buf.length`]` - 1` ",
                      "name": "byteOffset",
                      "type": "Integer",
                      "desc": "Where to begin searching in `buf`. **Default:** [`buf.length`]` - 1`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} If `value` is a string, this is its encoding. **Default:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "If `value` is a string, this is its encoding. **Default:** `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Identical to <a href=\"#buffer_buf_indexof_value_byteoffset_encoding\"><code>buf.indexOf()</code></a>, except <code>buf</code> is searched from back to front\ninstead of front to back.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;this buffer is a buffer&#39;);\n\n// Prints: 0\nconsole.log(buf.lastIndexOf(&#39;this&#39;));\n\n// Prints: 17\nconsole.log(buf.lastIndexOf(&#39;buffer&#39;));\n\n// Prints: 17\nconsole.log(buf.lastIndexOf(Buffer.from(&#39;buffer&#39;)));\n\n// Prints: 15\n// (97 is the decimal ASCII value for &#39;a&#39;)\nconsole.log(buf.lastIndexOf(97));\n\n// Prints: -1\nconsole.log(buf.lastIndexOf(Buffer.from(&#39;yolo&#39;)));\n\n// Prints: 5\nconsole.log(buf.lastIndexOf(&#39;buffer&#39;, 5));\n\n// Prints: -1\nconsole.log(buf.lastIndexOf(&#39;buffer&#39;, 4));\n\n\nconst utf16Buffer = Buffer.from(&#39;\\u039a\\u0391\\u03a3\\u03a3\\u0395&#39;, &#39;ucs2&#39;);\n\n// Prints: 6\nconsole.log(utf16Buffer.lastIndexOf(&#39;\\u03a3&#39;, undefined, &#39;ucs2&#39;));\n\n// Prints: 4\nconsole.log(utf16Buffer.lastIndexOf(&#39;\\u03a3&#39;, -5, &#39;ucs2&#39;));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleBE(offset[, noAssert])",
              "type": "method",
              "name": "readDoubleBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns\nlittle endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\n// Prints: 8.20788039913184e-304\nconsole.log(buf.readDoubleBE());\n\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE());\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readDoubleLE(1));\n\n// Warning: reads passed end of buffer!\n// This will result in a segmentation fault! Don&#39;t do this!\nconsole.log(buf.readDoubleLE(1, true));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleLE(offset[, noAssert])",
              "type": "method",
              "name": "readDoubleLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns\nlittle endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\n// Prints: 8.20788039913184e-304\nconsole.log(buf.readDoubleBE());\n\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE());\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readDoubleLE(1));\n\n// Warning: reads passed end of buffer!\n// This will result in a segmentation fault! Don&#39;t do this!\nconsole.log(buf.readDoubleLE(1, true));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readFloatBE(offset[, noAssert])",
              "type": "method",
              "name": "readFloatBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns\nlittle endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4]);\n\n// Prints: 2.387939260590663e-38\nconsole.log(buf.readFloatBE());\n\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE());\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readFloatLE(1));\n\n// Warning: reads passed end of buffer!\n// This will result in a segmentation fault! Don&#39;t do this!\nconsole.log(buf.readFloatLE(1, true));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readFloatLE(offset[, noAssert])",
              "type": "method",
              "name": "readFloatLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Number} ",
                    "name": "return",
                    "type": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns\nlittle endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4]);\n\n// Prints: 2.387939260590663e-38\nconsole.log(buf.readFloatBE());\n\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE());\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readFloatLE(1));\n\n// Warning: reads passed end of buffer!\n// This will result in a segmentation fault! Don&#39;t do this!\nconsole.log(buf.readFloatLE(1, true));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt8(offset[, noAssert])",
              "type": "method",
              "name": "readInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([-1, 5]);\n\n// Prints: -1\nconsole.log(buf.readInt8(0));\n\n// Prints: 5\nconsole.log(buf.readInt8(1));\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readInt8(2));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt16BE(offset[, noAssert])",
              "type": "method",
              "name": "readInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt16BE()</code> returns big endian,\n<code>readInt16LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 5]);\n\n// Prints: 5\nconsole.log(buf.readInt16BE());\n\n// Prints: 1280\nconsole.log(buf.readInt16LE());\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readInt16LE(1));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt16LE(offset[, noAssert])",
              "type": "method",
              "name": "readInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt16BE()</code> returns big endian,\n<code>readInt16LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 5]);\n\n// Prints: 5\nconsole.log(buf.readInt16BE());\n\n// Prints: 1280\nconsole.log(buf.readInt16LE());\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readInt16LE(1));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt32BE(offset[, noAssert])",
              "type": "method",
              "name": "readInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt32BE()</code> returns big endian,\n<code>readInt32LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 0, 0, 5]);\n\n// Prints: 5\nconsole.log(buf.readInt32BE());\n\n// Prints: 83886080\nconsole.log(buf.readInt32LE());\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readInt32LE(1));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt32LE(offset[, noAssert])",
              "type": "method",
              "name": "readInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt32BE()</code> returns big endian,\n<code>readInt32LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 0, 0, 5]);\n\n// Prints: 5\nconsole.log(buf.readInt32BE());\n\n// Prints: 83886080\nconsole.log(buf.readInt32LE());\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readInt32LE(1));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readIntBE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} How many bytes to read. Must satisfy: `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "How many bytes to read. Must satisfy: `0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` and `byteLength` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` and `byteLength` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as a two&#39;s complement signed value. Supports up to 48\nbits of accuracy.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\n// Prints: -546f87a9cbee\nconsole.log(buf.readIntLE(0, 6).toString(16));\n\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(0, 6).toString(16));\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readIntBE(1, 6).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readIntLE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} How many bytes to read. Must satisfy: `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "How many bytes to read. Must satisfy: `0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` and `byteLength` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` and `byteLength` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as a two&#39;s complement signed value. Supports up to 48\nbits of accuracy.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\n// Prints: -546f87a9cbee\nconsole.log(buf.readIntLE(0, 6).toString(16));\n\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(0, 6).toString(16));\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readIntBE(1, 6).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt8(offset[, noAssert])",
              "type": "method",
              "name": "readUInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, -2]);\n\n// Prints: 1\nconsole.log(buf.readUInt8(0));\n\n// Prints: 254\nconsole.log(buf.readUInt8(1));\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readUInt8(2));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16BE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>\nreturns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56]);\n\n// Prints: 1234\nconsole.log(buf.readUInt16BE(0).toString(16));\n\n// Prints: 3412\nconsole.log(buf.readUInt16LE(0).toString(16));\n\n// Prints: 3456\nconsole.log(buf.readUInt16BE(1).toString(16));\n\n// Prints: 5634\nconsole.log(buf.readUInt16LE(1).toString(16));\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readUInt16LE(2).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16LE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>\nreturns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56]);\n\n// Prints: 1234\nconsole.log(buf.readUInt16BE(0).toString(16));\n\n// Prints: 3412\nconsole.log(buf.readUInt16LE(0).toString(16));\n\n// Prints: 3456\nconsole.log(buf.readUInt16BE(1).toString(16));\n\n// Prints: 5634\nconsole.log(buf.readUInt16LE(1).toString(16));\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readUInt16LE(2).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32BE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt32BE()</code> returns big endian,\n<code>readUInt32LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\n// Prints: 12345678\nconsole.log(buf.readUInt32BE(0).toString(16));\n\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(0).toString(16));\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readUInt32LE(1).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32LE(offset[, noAssert])",
              "type": "method",
              "name": "readUInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt32BE()</code> returns big endian,\n<code>readUInt32LE()</code> returns little endian).</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\n// Prints: 12345678\nconsole.log(buf.readUInt32BE(0).toString(16));\n\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(0).toString(16));\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readUInt32LE(1).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUIntBE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readUIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} How many bytes to read. Must satisfy: `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "How many bytes to read. Must satisfy: `0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` and `byteLength` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` and `byteLength` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as an unsigned integer. Supports up to 48\nbits of accuracy.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\n// Prints: 1234567890ab\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n\n// Prints: ab9078563412\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUIntLE(offset, byteLength[, noAssert])",
              "type": "method",
              "name": "readUIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} ",
                    "name": "return",
                    "type": "Integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {Integer} Where to start reading. Must satisfy: `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start reading. Must satisfy: `0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} How many bytes to read. Must satisfy: `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "How many bytes to read. Must satisfy: `0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `offset` and `byteLength` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `offset` and `byteLength` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as an unsigned integer. Supports up to 48\nbits of accuracy.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but\nthe result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\n// Prints: 1234567890ab\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n\n// Prints: ab9078563412\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n\n// Throws an exception: RangeError: Index out of range\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.slice([start[, end]])",
              "type": "method",
              "name": "slice",
              "meta": {
                "added": [
                  "v0.3.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} ",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`start` {Integer} Where the new `Buffer` will start. **Default:** `0` ",
                      "name": "start",
                      "type": "Integer",
                      "desc": "Where the new `Buffer` will start. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {Integer} Where the new `Buffer` will end (not inclusive). **Default:** [`buf.length`] ",
                      "name": "end",
                      "type": "Integer",
                      "desc": "Where the new `Buffer` will end (not inclusive). **Default:** [`buf.length`]",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new <code>Buffer</code> that references the same memory as the original, but\noffset and cropped by the <code>start</code> and <code>end</code> indices.</p>\n<p><strong>Note that modifying the new <code>Buffer</code> slice will modify the memory in the\noriginal <code>Buffer</code> because the allocated memory of the two objects overlap.</strong></p>\n<p>Example: Create a <code>Buffer</code> with the ASCII alphabet, take a slice, and then modify\none byte from the original <code>Buffer</code></p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0 ; i &lt; 26 ; i++) {\n  // 97 is the decimal ASCII value for &#39;a&#39;\n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.slice(0, 3);\n\n// Prints: abc\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));\n\nbuf1[0] = 33;\n\n// Prints: !bc\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));\n</code></pre>\n<p>Specifying negative indexes causes the slice to be generated relative to the\nend of <code>buf</code> rather than the beginning.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;buffer&#39;);\n\n// Prints: buffe\n// (Equivalent to buf.slice(0, 5))\nconsole.log(buf.slice(-6, -1).toString());\n\n// Prints: buff\n// (Equivalent to buf.slice(0, 4))\nconsole.log(buf.slice(-6, -2).toString());\n\n// Prints: uff\n// (Equivalent to buf.slice(1, 4))\nconsole.log(buf.slice(-5, -2).toString());\n</code></pre>\n"
            },
            {
              "textRaw": "buf.swap16()",
              "type": "method",
              "name": "swap16",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf` ",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of unsigned 16-bit integers and swaps the byte-order\n<em>in-place</em>. Throws a <code>RangeError</code> if <a href=\"#buffer_buf_length\"><code>buf.length</code></a> is not a multiple of 2.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\n// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;\nconsole.log(buf1);\n\nbuf1.swap16();\n\n// Prints: &lt;Buffer 02 01 04 03 06 05 08 07&gt;\nconsole.log(buf1);\n\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\n// Throws an exception: RangeError: Buffer size must be a multiple of 16-bits\nbuf2.swap16();\n</code></pre>\n"
            },
            {
              "textRaw": "buf.swap32()",
              "type": "method",
              "name": "swap32",
              "meta": {
                "added": [
                  "v5.10.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf` ",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of unsigned 32-bit integers and swaps the byte-order\n<em>in-place</em>. Throws a <code>RangeError</code> if <a href=\"#buffer_buf_length\"><code>buf.length</code></a> is not a multiple of 4.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\n// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;\nconsole.log(buf1);\n\nbuf1.swap32();\n\n// Prints: &lt;Buffer 04 03 02 01 08 07 06 05&gt;\nconsole.log(buf1);\n\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\n// Throws an exception: RangeError: Buffer size must be a multiple of 32-bits\nbuf2.swap32();\n</code></pre>\n"
            },
            {
              "textRaw": "buf.swap64()",
              "type": "method",
              "name": "swap64",
              "meta": {
                "added": [
                  "v6.3.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf` ",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of 64-bit numbers and swaps the byte-order <em>in-place</em>.\nThrows a <code>RangeError</code> if <a href=\"#buffer_buf_length\"><code>buf.length</code></a> is not a multiple of 8.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\n// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;\nconsole.log(buf1);\n\nbuf1.swap64();\n\n// Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt;\nconsole.log(buf1);\n\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\n// Throws an exception: RangeError: Buffer size must be a multiple of 64-bits\nbuf2.swap64();\n</code></pre>\n<p>Note that JavaScript cannot encode 64-bit integers. This method is intended\nfor working with 64-bit floats.</p>\n"
            },
            {
              "textRaw": "buf.toString([encoding[, start[, end]]])",
              "type": "method",
              "name": "toString",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {String} ",
                    "name": "return",
                    "type": "String"
                  },
                  "params": [
                    {
                      "textRaw": "`encoding` {String} The character encoding to decode to. **Default:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "The character encoding to decode to. **Default:** `'utf8'`",
                      "optional": true
                    },
                    {
                      "textRaw": "`start` {Integer} The byte offset to start decoding at. **Default:** `0` ",
                      "name": "start",
                      "type": "Integer",
                      "desc": "The byte offset to start decoding at. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {Integer} The byte offset to stop decoding at (not inclusive). **Default:** [`buf.length`] ",
                      "name": "end",
                      "type": "Integer",
                      "desc": "The byte offset to stop decoding at (not inclusive). **Default:** [`buf.length`]",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Decodes <code>buf</code> to a string according to the specified character encoding in\n<code>encoding</code>. <code>start</code> and <code>end</code> may be passed to decode only a subset of <code>buf</code>.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0 ; i &lt; 26 ; i++) {\n  // 97 is the decimal ASCII value for &#39;a&#39;\n  buf1[i] = i + 97;\n}\n\n// Prints: abcdefghijklmnopqrstuvwxyz\nconsole.log(buf1.toString(&#39;ascii&#39;));\n\n// Prints: abcde\nconsole.log(buf1.toString(&#39;ascii&#39;, 0, 5));\n\n\nconst buf2 = Buffer.from(&#39;tést&#39;);\n\n// Prints: 74c3a97374\nconsole.log(buf2.toString(&#39;hex&#39;));\n\n// Prints: té\nconsole.log(buf2.toString(&#39;utf8&#39;, 0, 3));\n\n// Prints: té\nconsole.log(buf2.toString(undefined, 0, 3));\n</code></pre>\n"
            },
            {
              "textRaw": "buf.toJSON()",
              "type": "method",
              "name": "toJSON",
              "meta": {
                "added": [
                  "v0.9.2"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object} ",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Returns a JSON representation of <code>buf</code>. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\"><code>JSON.stringify()</code></a> implicitly calls\nthis function when stringifying a <code>Buffer</code> instance.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\n// Prints: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}\nconsole.log(json);\n\nconst copy = JSON.parse(json, (key, value) =&gt; {\n  return value &amp;&amp; value.type === &#39;Buffer&#39;\n    ? Buffer.from(value.data)\n    : value;\n});\n\n// Prints: &lt;Buffer 01 02 03 04 05&gt;\nconsole.log(copy);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.values()",
              "type": "method",
              "name": "values",
              "meta": {
                "added": [
                  "v1.1.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator} ",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> for <code>buf</code> values (bytes). This function is\ncalled automatically when a <code>Buffer</code> is used in a <code>for..of</code> statement.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;buffer&#39;);\n\n// Prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\nfor (const value of buf.values()) {\n  console.log(value);\n}\n\n// Prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\nfor (const value of buf) {\n  console.log(value);\n}\n</code></pre>\n"
            },
            {
              "textRaw": "buf.write(string[, offset[, length]][, encoding])",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "v0.1.90"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} Number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "Number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`string` {String} String to be written to `buf` ",
                      "name": "string",
                      "type": "String",
                      "desc": "String to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing `string`. **Default:** `0` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing `string`. **Default:** `0`",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` {Integer} How many bytes to write. **Default:** `buf.length - offset` ",
                      "name": "length",
                      "type": "Integer",
                      "desc": "How many bytes to write. **Default:** `buf.length - offset`",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} The character encoding of `string`. **Default:** `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "desc": "The character encoding of `string`. **Default:** `'utf8'`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "length",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>string</code> to <code>buf</code> at <code>offset</code> according to the character encoding in <code>encoding</code>.\nThe <code>length</code> parameter is the number of bytes to write. If <code>buf</code> did not contain\nenough space to fit the entire string, only a partial amount of <code>string</code> will\nbe written. However, partially encoded characters will not be written.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(256);\n\nconst len = buf.write(&#39;\\u00bd + \\u00bc = \\u00be&#39;, 0);\n\n// Prints: 12 bytes: ½ + ¼ = ¾\nconsole.log(`${len} bytes: ${buf.toString(&#39;utf8&#39;, 0, len)}`);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleBE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeDoubleBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when\n<code>value</code> is anything other than a 64-bit double.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\n// Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\nconsole.log(buf);\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\n// Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleLE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeDoubleLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 8` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 8`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when\n<code>value</code> is anything other than a 64-bit double.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\n// Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\nconsole.log(buf);\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\n// Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeFloatBE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeFloatBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when\n<code>value</code> is anything other than a 32-bit float.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\n// Prints: &lt;Buffer 4f 4a fe bb&gt;\nconsole.log(buf);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\n// Prints: &lt;Buffer bb fe 4a 4f&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeFloatLE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeFloatLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Number} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Number",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when\n<code>value</code> is anything other than a 32-bit float.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\n// Prints: &lt;Buffer 4f 4a fe bb&gt;\nconsole.log(buf);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\n// Prints: &lt;Buffer bb fe 4a 4f&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt8(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a valid\nsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything other than\na signed 8-bit integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\n\n// Prints: &lt;Buffer 02 fe&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt16BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is undefined\nwhen <code>value</code> is anything other than a signed 16-bit integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt16BE(0x0102, 0);\nbuf.writeInt16LE(0x0304, 2);\n\n// Prints: &lt;Buffer 01 02 04 03&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt16LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is undefined\nwhen <code>value</code> is anything other than a signed 16-bit integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt16BE(0x0102, 0);\nbuf.writeInt16LE(0x0304, 2);\n\n// Prints: &lt;Buffer 01 02 04 03&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt32BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is undefined\nwhen <code>value</code> is anything other than a signed 32-bit integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeInt32BE(0x01020304, 0);\nbuf.writeInt32LE(0x05060708, 4);\n\n// Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt32LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is undefined\nwhen <code>value</code> is anything other than a signed 32-bit integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeInt32BE(0x01020304, 0);\nbuf.writeInt32LE(0x05060708, 4);\n\n// Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeIntBE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} How many bytes to write. Must satisfy: `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "How many bytes to write. Must satisfy: `0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value`, `offset`, and `byteLength` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value`, `offset`, and `byteLength` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than a signed integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\n// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\nconsole.log(buf);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\n// Prints: &lt;Buffer ab 90 78 56 34 12&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeIntLE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} How many bytes to write. Must satisfy: `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "How many bytes to write. Must satisfy: `0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value`, `offset`, and `byteLength` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value`, `offset`, and `byteLength` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than a signed integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\n// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\nconsole.log(buf);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\n// Prints: &lt;Buffer ab 90 78 56 34 12&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt8(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 1` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 1`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a\nvalid unsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything\nother than an unsigned 8-bit integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\n// Prints: &lt;Buffer 03 04 23 42&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\n// Prints: &lt;Buffer de ad be ef&gt;\nconsole.log(buf);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\n// Prints: &lt;Buffer ad de ef be&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 2` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 2`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\n// Prints: &lt;Buffer de ad be ef&gt;\nconsole.log(buf);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\n// Prints: &lt;Buffer ad de ef be&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32BE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\n// Prints: &lt;Buffer fe ed fa ce&gt;\nconsole.log(buf);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\n// Prints: &lt;Buffer ce fa ed fe&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32LE(value, offset[, noAssert])",
              "type": "method",
              "name": "writeUInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - 4`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value` and `offset` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value` and `offset` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\n// Prints: &lt;Buffer fe ed fa ce&gt;\nconsole.log(buf);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\n// Prints: &lt;Buffer ce fa ed fe&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUIntBE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeUIntBE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} How many bytes to write. Must satisfy: `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "How many bytes to write. Must satisfy: `0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value`, `offset`, and `byteLength` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value`, `offset`, and `byteLength` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than an unsigned integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\n// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\nconsole.log(buf);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\n// Prints: &lt;Buffer ab 90 78 56 34 12&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUIntLE(value, offset, byteLength[, noAssert])",
              "type": "method",
              "name": "writeUIntLE",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Integer} `offset` plus the number of bytes written ",
                    "name": "return",
                    "type": "Integer",
                    "desc": "`offset` plus the number of bytes written"
                  },
                  "params": [
                    {
                      "textRaw": "`value` {Integer} Number to be written to `buf` ",
                      "name": "value",
                      "type": "Integer",
                      "desc": "Number to be written to `buf`"
                    },
                    {
                      "textRaw": "`offset` {Integer} Where to start writing. Must satisfy: `0 <= offset <= buf.length - byteLength` ",
                      "name": "offset",
                      "type": "Integer",
                      "desc": "Where to start writing. Must satisfy: `0 <= offset <= buf.length - byteLength`"
                    },
                    {
                      "textRaw": "`byteLength` {Integer} How many bytes to write. Must satisfy: `0 < byteLength <= 6` ",
                      "name": "byteLength",
                      "type": "Integer",
                      "desc": "How many bytes to write. Must satisfy: `0 < byteLength <= 6`"
                    },
                    {
                      "textRaw": "`noAssert` {Boolean} Skip `value`, `offset`, and `byteLength` validation? **Default:** `false` ",
                      "name": "noAssert",
                      "type": "Boolean",
                      "desc": "Skip `value`, `offset`, and `byteLength` validation? **Default:** `false`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than an unsigned integer.</p>\n<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond\nthe end of <code>buf</code>, but the result should be considered undefined behavior.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\n// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\nconsole.log(buf);\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\n// Prints: &lt;Buffer ab 90 78 56 34 12&gt;\nconsole.log(buf);\n</code></pre>\n"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`array` {Array} An array of bytes to copy from ",
                  "name": "array",
                  "type": "Array",
                  "desc": "An array of bytes to copy from"
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">// Creates a new Buffer containing the ASCII bytes of the string &#39;buffer&#39;\nconst buf = new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "array"
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">// Creates a new Buffer containing the ASCII bytes of the string &#39;buffer&#39;\nconst buf = new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`buffer` {Buffer} An existing `Buffer` to copy data from ",
                  "name": "buffer",
                  "type": "Buffer",
                  "desc": "An existing `Buffer` to copy data from"
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;buffer&#39;);\nconst buf2 = new Buffer(buf1);\n\nbuf1[0] = 0x61;\n\n// Prints: auffer\nconsole.log(buf1.toString());\n\n// Prints: buffer\nconsole.log(buf2.toString());\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "buffer"
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;buffer&#39;);\nconst buf2 = new Buffer(buf1);\n\nbuf1[0] = 0x61;\n\n// Prints: auffer\nconsole.log(buf1.toString());\n\n// Prints: buffer\nconsole.log(buf2.toString());\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`arrayBuffer` {ArrayBuffer} The `.buffer` property of a [`TypedArray`] or [`ArrayBuffer`] ",
                  "name": "arrayBuffer",
                  "type": "ArrayBuffer",
                  "desc": "The `.buffer` property of a [`TypedArray`] or [`ArrayBuffer`]"
                },
                {
                  "textRaw": "`byteOffset` {Integer} Where to start copying from `arrayBuffer`. **Default:** `0` ",
                  "name": "byteOffset",
                  "type": "Integer",
                  "desc": "Where to start copying from `arrayBuffer`. **Default:** `0`",
                  "optional": true
                },
                {
                  "textRaw": "`length` {Integer} How many bytes to copy from `arrayBuffer`. **Default:** `arrayBuffer.length - byteOffset` ",
                  "name": "length",
                  "type": "Integer",
                  "desc": "How many bytes to copy from `arrayBuffer`. **Default:** `arrayBuffer.length - byteOffset`",
                  "optional": true
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated: Use\n<a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a>\ninstead.</p>\n<p>When passed a reference to the <code>.buffer</code> property of a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance,\nthe newly created <code>Buffer</code> will share the same allocated memory as the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>.</p>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`\nconst buf = new Buffer(arr.buffer);\n\n// Prints: &lt;Buffer 88 13 a0 0f&gt;\nconsole.log(buf);\n\n// Changing the original Uint16Array changes the Buffer also\narr[1] = 6000;\n\n// Prints: &lt;Buffer 88 13 70 17&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "arrayBuffer"
                },
                {
                  "name": "byteOffset",
                  "optional": true
                },
                {
                  "name": "length",
                  "optional": true
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated: Use\n<a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a>\ninstead.</p>\n<p>When passed a reference to the <code>.buffer</code> property of a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance,\nthe newly created <code>Buffer</code> will share the same allocated memory as the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>.</p>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`\nconst buf = new Buffer(arr.buffer);\n\n// Prints: &lt;Buffer 88 13 a0 0f&gt;\nconsole.log(buf);\n\n// Changing the original Uint16Array changes the Buffer also\narr[1] = 6000;\n\n// Prints: &lt;Buffer 88 13 70 17&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`size` {Integer} The desired length of the new `Buffer` ",
                  "name": "size",
                  "type": "Integer",
                  "desc": "The desired length of the new `Buffer`"
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated: Use <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> instead (also see\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>).</p>\n<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  If the <code>size</code> is larger than\n<a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a> or smaller than 0, a <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> will be thrown.\nA zero-length <code>Buffer</code> will be created if <code>size</code> is 0.</p>\n<p>Unlike <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffers</code></a>, the underlying memory for <code>Buffer</code> instances\ncreated in this way is <em>not initialized</em>. The contents of a newly created <code>Buffer</code>\nare unknown and <em>could contain sensitive data</em>. Use\n<a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc(size)</code></a> instead to initialize a <code>Buffer</code> to zeroes.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(10);\n\n// Prints: (contents may vary): &lt;Buffer 48 21 4b 00 00 00 00 00 30 dd&gt;\nconsole.log(buf);\n\nbuf.fill(0);\n\n// Prints: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "size"
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated: Use <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> instead (also see\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>).</p>\n<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  If the <code>size</code> is larger than\n<a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a> or smaller than 0, a <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> will be thrown.\nA zero-length <code>Buffer</code> will be created if <code>size</code> is 0.</p>\n<p>Unlike <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffers</code></a>, the underlying memory for <code>Buffer</code> instances\ncreated in this way is <em>not initialized</em>. The contents of a newly created <code>Buffer</code>\nare unknown and <em>could contain sensitive data</em>. Use\n<a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc(size)</code></a> instead to initialize a <code>Buffer</code> to zeroes.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(10);\n\n// Prints: (contents may vary): &lt;Buffer 48 21 4b 00 00 00 00 00 30 dd&gt;\nconsole.log(buf);\n\nbuf.fill(0);\n\n// Prints: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`string` {String} String to encode ",
                  "name": "string",
                  "type": "String",
                  "desc": "String to encode"
                },
                {
                  "textRaw": "`encoding` {String} The encoding of `string`. **Default:** `'utf8'` ",
                  "name": "encoding",
                  "type": "String",
                  "desc": "The encoding of `string`. **Default:** `'utf8'`",
                  "optional": true
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated:\nUse <a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a> instead.</p>\n<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>string</code>. If\nprovided, the <code>encoding</code> parameter identifies the character encoding of <code>string</code>.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;this is a tést&#39;);\n\n// Prints: this is a tést\nconsole.log(buf1.toString());\n\n// Prints: this is a tC)st\nconsole.log(buf1.toString(&#39;ascii&#39;));\n\n\nconst buf2 = new Buffer(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\n\n// Prints: this is a tést\nconsole.log(buf2.toString());\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "string"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated:\nUse <a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a> instead.</p>\n<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>string</code>. If\nprovided, the <code>encoding</code> parameter identifies the character encoding of <code>string</code>.</p>\n<p>Examples:</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;this is a tést&#39;);\n\n// Prints: this is a tést\nconsole.log(buf1.toString());\n\n// Prints: this is a tC)st\nconsole.log(buf1.toString(&#39;ascii&#39;));\n\n\nconst buf2 = new Buffer(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\n\n// Prints: this is a tést\nconsole.log(buf2.toString());\n</code></pre>\n"
            }
          ]
        },
        {
          "textRaw": "Class: SlowBuffer",
          "type": "class",
          "name": "SlowBuffer",
          "meta": {
            "deprecated": [
              "v6.0.0"
            ]
          },
          "stability": 0,
          "stabilityText": "Deprecated: Use [`Buffer.allocUnsafeSlow()`] instead.",
          "desc": "<p>Returns an un-pooled <code>Buffer</code>.</p>\n<p>In order to avoid the garbage collection overhead of creating many individually\nallocated <code>Buffer</code> instances, by default allocations under 4KB are sliced from a\nsingle larger allocated object. This approach improves both performance and memory\nusage since v8 does not need to track and cleanup as many <code>Persistent</code> objects.</p>\n<p>In the case where a developer may need to retain a small chunk of memory from a\npool for an indeterminate amount of time, it may be appropriate to create an\nun-pooled <code>Buffer</code> instance using <code>SlowBuffer</code> then copy out the relevant bits.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">// Need to keep around a few small chunks of memory\nconst store = [];\n\nsocket.on(&#39;readable&#39;, () =&gt; {\n  const data = socket.read();\n\n  // Allocate for retained data\n  const sb = SlowBuffer(10);\n\n  // Copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n\n  store.push(sb);\n});\n</code></pre>\n<p>Use of <code>SlowBuffer</code> should be used only as a last resort <em>after</em> a developer\nhas observed undue memory retention in their applications.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`size` {Integer} The desired length of the new `SlowBuffer` ",
                  "name": "size",
                  "type": "Integer",
                  "desc": "The desired length of the new `SlowBuffer`"
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  If the <code>size</code> is larger than\n<a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a> or smaller than 0, a <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> will be thrown.\nA zero-length <code>Buffer</code> will be created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The\ncontents of a newly created <code>SlowBuffer</code> are unknown and could contain\nsensitive data. Use <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> to zeroes.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const SlowBuffer = require(&#39;buffer&#39;).SlowBuffer;\n\nconst buf = new SlowBuffer(5);\n\n// Prints: (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;\nconsole.log(buf);\n\nbuf.fill(0);\n\n// Prints: &lt;Buffer 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "size"
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  If the <code>size</code> is larger than\n<a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a> or smaller than 0, a <a href=\"errors.html#errors_class_rangeerror\"><code>RangeError</code></a> will be thrown.\nA zero-length <code>Buffer</code> will be created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The\ncontents of a newly created <code>SlowBuffer</code> are unknown and could contain\nsensitive data. Use <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> to zeroes.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const SlowBuffer = require(&#39;buffer&#39;).SlowBuffer;\n\nconst buf = new SlowBuffer(5);\n\n// Prints: (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;\nconsole.log(buf);\n\nbuf.fill(0);\n\n// Prints: &lt;Buffer 00 00 00 00 00&gt;\nconsole.log(buf);\n</code></pre>\n"
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "`INSPECT_MAX_BYTES` {Integer} **Default:** `50` ",
          "type": "Integer",
          "name": "INSPECT_MAX_BYTES",
          "meta": {
            "added": [
              "v0.5.4"
            ]
          },
          "desc": "<p>Returns the maximum number of bytes that will be returned when\n<code>buf.inspect()</code> is called. This can be overridden by user modules. See\n<a href=\"util.html#util_util_inspect_object_options\"><code>util.inspect()</code></a> for more details on <code>buf.inspect()</code> behavior.</p>\n<p>Note that this is a property on the <code>buffer</code> module returned by\n<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>\n",
          "shortDesc": "**Default:** `50`"
        },
        {
          "textRaw": "`kMaxLength` {Integer} The largest size allowed for a single `Buffer` instance ",
          "type": "Integer",
          "name": "kMaxLength",
          "meta": {
            "added": [
              "v3.0.0"
            ]
          },
          "desc": "<p>On 32-bit architectures, this value is <code>(2^30)-1</code> (~1GB).\nOn 64-bit architectures, this value is <code>(2^31)-1</code> (~2GB).</p>\n<p>Note that this is a property on the <code>buffer</code> module returned by\n<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>\n",
          "shortDesc": "The largest size allowed for a single `Buffer` instance"
        }
      ],
      "methods": [
        {
          "textRaw": "buffer.transcode(source, fromEnc, toEnc)",
          "type": "method",
          "name": "transcode",
          "meta": {
            "added": [
              "v7.1.0"
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`source` {Buffer} A `Buffer` instance ",
                  "name": "source",
                  "type": "Buffer",
                  "desc": "A `Buffer` instance"
                },
                {
                  "textRaw": "`fromEnc` {String} The current encoding ",
                  "name": "fromEnc",
                  "type": "String",
                  "desc": "The current encoding"
                },
                {
                  "textRaw": "`toEnc` {String} To target encoding ",
                  "name": "toEnc",
                  "type": "String",
                  "desc": "To target encoding"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "source"
                },
                {
                  "name": "fromEnc"
                },
                {
                  "name": "toEnc"
                }
              ]
            }
          ],
          "desc": "<p>Re-encodes the given <code>Buffer</code> instance from one character encoding to another.\nReturns a new <code>Buffer</code> instance.</p>\n<p>Throws if the <code>fromEnc</code> or <code>toEnc</code> specify invalid character encodings or if\nconversion from <code>fromEnc</code> to <code>toEnc</code> is not permitted.</p>\n<p>The transcoding process will use substitution characters if a given byte\nsequence cannot be adequately represented in the target encoding. For instance:</p>\n<pre><code class=\"lang-js\">const buffer = require(&#39;buffer&#39;);\n\nconst newBuf = buffer.transcode(Buffer.from(&#39;€&#39;), &#39;utf8&#39;, &#39;ascii&#39;);\nconsole.log(newBuf.toString(&#39;ascii&#39;));\n// Prints: &#39;?&#39;\n</code></pre>\n<p>Because the Euro (<code>€</code>) sign is not representable in US-ASCII, it is replaced\nwith <code>?</code> in the transcoded <code>Buffer</code>.</p>\n<p>Note that this is a property on the <code>buffer</code> module returned by\n<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "Buffer"
    }
  ]
}
