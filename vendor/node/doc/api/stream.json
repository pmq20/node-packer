{
  "source": "doc/api/stream.md",
  "modules": [
    {
      "textRaw": "Stream",
      "name": "stream",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>A stream is an abstract interface for working with streaming data in Node.js.\nThe <code>stream</code> module provides a base API that makes it easy to build objects\nthat implement the stream interface.</p>\n<p>There are many stream objects provided by Node.js. For instance, a\n<a href=\"http.html#http_class_http_incomingmessage\">request to an HTTP server</a> and <a href=\"process.html#process_process_stdout\"><code>process.stdout</code></a>\nare both stream instances.</p>\n<p>Streams can be readable, writable, or both. All streams are instances of\n<a href=\"events.html#events_class_eventemitter\"><code>EventEmitter</code></a>.</p>\n<p>The <code>stream</code> module can be accessed using:</p>\n<pre><code class=\"lang-js\">const stream = require(&#39;stream&#39;);\n</code></pre>\n<p>While it is important for all Node.js users to understand how streams work,\nthe <code>stream</code> module itself is most useful for developers that are creating new\ntypes of stream instances. Developer&#39;s who are primarily <em>consuming</em> stream\nobjects will rarely (if ever) have need to use the <code>stream</code> module directly.</p>\n",
      "modules": [
        {
          "textRaw": "Organization of this Document",
          "name": "organization_of_this_document",
          "desc": "<p>This document is divided into two primary sections with a third section for\nadditional notes. The first section explains the elements of the stream API that\nare required to <em>use</em> streams within an application. The second section explains\nthe elements of the API that are required to <em>implement</em> new types of streams.</p>\n",
          "type": "module",
          "displayName": "Organization of this Document"
        },
        {
          "textRaw": "Types of Streams",
          "name": "types_of_streams",
          "desc": "<p>There are four fundamental stream types within Node.js:</p>\n<ul>\n<li><a href=\"#stream_class_stream_readable\">Readable</a> - streams from which data can be read (for example\n<a href=\"fs.html#fs_fs_createreadstream_path_options\"><code>fs.createReadStream()</code></a>).</li>\n<li><a href=\"#stream_class_stream_writable\">Writable</a> - streams to which data can be written (for example\n<a href=\"fs.html#fs_fs_createwritestream_path_options\"><code>fs.createWriteStream()</code></a>).</li>\n<li><a href=\"#stream_class_stream_duplex\">Duplex</a> - streams that are both Readable and Writable (for example\n<a href=\"net.html#net_class_net_socket\"><code>net.Socket</code></a>).</li>\n<li><a href=\"#stream_class_stream_transform\">Transform</a> - Duplex streams that can modify or transform the data as it\nis written and read (for example <a href=\"zlib.html#zlib_zlib_createdeflate_options\"><code>zlib.createDeflate()</code></a>).</li>\n</ul>\n",
          "modules": [
            {
              "textRaw": "Object Mode",
              "name": "object_mode",
              "desc": "<p>All streams created by Node.js APIs operate exclusively on strings and <code>Buffer</code>\nobjects. It is possible, however, for stream implementations to work with other\ntypes of JavaScript values (with the exception of <code>null</code>, which serves a special\npurpose within streams). Such streams are considered to operate in &quot;object\nmode&quot;.</p>\n<p>Stream instances are switched into object mode using the <code>objectMode</code> option\nwhen the stream is created. Attempting to switch an existing stream into\nobject mode is not safe.</p>\n",
              "type": "module",
              "displayName": "Object Mode"
            }
          ],
          "miscs": [
            {
              "textRaw": "Buffering",
              "name": "Buffering",
              "type": "misc",
              "desc": "<p>Both <a href=\"#stream_class_stream_writable\">Writable</a> and <a href=\"#stream_class_stream_readable\">Readable</a> streams will store data in an internal\nbuffer that can be retrieved using <code>writable._writableState.getBuffer()</code> or\n<code>readable._readableState.buffer</code>, respectively.</p>\n<p>The amount of data potentially buffered depends on the <code>highWaterMark</code> option\npassed into the streams constructor. For normal streams, the <code>highWaterMark</code>\noption specifies a total number of bytes. For streams operating in object mode,\nthe <code>highWaterMark</code> specifies a total number of objects.</p>\n<p>Data is buffered in Readable streams when the implementation calls\n<a href=\"#stream_readable_push_chunk_encoding\"><code>stream.push(chunk)</code></a>. If the consumer of the Stream does not\ncall <a href=\"#stream_readable_read_size\"><code>stream.read()</code></a>, the data will sit in the internal\nqueue until it is consumed.</p>\n<p>Once the total size of the internal read buffer reaches the threshold specified\nby <code>highWaterMark</code>, the stream will temporarily stop reading data from the\nunderlying resource until the data currently buffered can be consumed (that is,\nthe stream will stop calling the internal <code>readable._read()</code> method that is\nused to fill the read buffer).</p>\n<p>Data is buffered in Writable streams when the\n<a href=\"#stream_writable_write_chunk_encoding_callback\"><code>writable.write(chunk)</code></a> method is called repeatedly. While the\ntotal size of the internal write buffer is below the threshold set by\n<code>highWaterMark</code>, calls to <code>writable.write()</code> will return <code>true</code>. Once\nthe size of the internal buffer reaches or exceeds the <code>highWaterMark</code>, <code>false</code>\nwill be returned.</p>\n<p>A key goal of the <code>stream</code> API, particularly the <a href=\"#stream_readable_pipe_destination_options\"><code>stream.pipe()</code></a> method,\nis to limit the buffering of data to acceptable levels such that sources and\ndestinations of differing speeds will not overwhelm the available memory.</p>\n<p>Because <a href=\"#stream_class_stream_duplex\">Duplex</a> and <a href=\"#stream_class_stream_transform\">Transform</a> streams are both Readable and Writable,\neach maintain <em>two</em> separate internal buffers used for reading and writing,\nallowing each side to operate independently of the other while maintaining an\nappropriate and efficient flow of data. For example, <a href=\"net.html#net_class_net_socket\"><code>net.Socket</code></a> instances\nare <a href=\"#stream_class_stream_duplex\">Duplex</a> streams whose Readable side allows consumption of data received\n<em>from</em> the socket and whose Writable side allows writing data <em>to</em> the socket.\nBecause data may be written to the socket at a faster or slower rate than data\nis received, it is important for each side to operate (and buffer) independently\nof the other.</p>\n"
            }
          ],
          "type": "module",
          "displayName": "Types of Streams"
        }
      ],
      "miscs": [
        {
          "textRaw": "API for Stream Consumers",
          "name": "API for Stream Consumers",
          "type": "misc",
          "desc": "<p>Almost all Node.js applications, no matter how simple, use streams in some\nmanner. The following is an example of using streams in a Node.js application\nthat implements an HTTP server:</p>\n<pre><code class=\"lang-js\">const http = require(&#39;http&#39;);\n\nconst server = http.createServer( (req, res) =&gt; {\n  // req is an http.IncomingMessage, which is a Readable Stream\n  // res is an http.ServerResponse, which is a Writable Stream\n\n  let body = &#39;&#39;;\n  // Get the data as utf8 strings.\n  // If an encoding is not set, Buffer objects will be received.\n  req.setEncoding(&#39;utf8&#39;);\n\n  // Readable streams emit &#39;data&#39; events once a listener is added\n  req.on(&#39;data&#39;, (chunk) =&gt; {\n    body += chunk;\n  });\n\n  // the end event indicates that the entire body has been received\n  req.on(&#39;end&#39;, () =&gt; {\n    try {\n      const data = JSON.parse(body);\n      // write back something interesting to the user:\n      res.write(typeof data);\n      res.end();\n    } catch (er) {\n      // uh oh!  bad json!\n      res.statusCode = 400;\n      return res.end(`error: ${er.message}`);\n    }\n  });\n});\n\nserver.listen(1337);\n\n// $ curl localhost:1337 -d &#39;{}&#39;\n// object\n// $ curl localhost:1337 -d &#39;&quot;foo&quot;&#39;\n// string\n// $ curl localhost:1337 -d &#39;not json&#39;\n// error: Unexpected token o\n</code></pre>\n<p><a href=\"#stream_class_stream_writable\">Writable</a> streams (such as <code>res</code> in the example) expose methods such as\n<code>write()</code> and <code>end()</code> that are used to write data onto the stream.</p>\n<p><a href=\"#stream_class_stream_readable\">Readable</a> streams use the <a href=\"events.html#events_class_eventemitter\"><code>EventEmitter</code></a> API for notifying application\ncode when data is available to be read off the stream. That available data can\nbe read from the stream in multiple ways.</p>\n<p>Both <a href=\"#stream_class_stream_writable\">Writable</a> and <a href=\"#stream_class_stream_readable\">Readable</a> streams use the <a href=\"events.html#events_class_eventemitter\"><code>EventEmitter</code></a> API in\nvarious ways to communicate the current state of the stream.</p>\n<p><a href=\"#stream_class_stream_duplex\">Duplex</a> and <a href=\"#stream_class_stream_transform\">Transform</a> streams are both <a href=\"#stream_class_stream_writable\">Writable</a> and <a href=\"#stream_class_stream_readable\">Readable</a>.</p>\n<p>Applications that are either writing data to or consuming data from a stream\nare not required to implement the stream interfaces directly and will generally\nhave no reason to call <code>require(&#39;stream&#39;)</code>.</p>\n<p>Developers wishing to implement new types of streams should refer to the\nsection <a href=\"#stream_api_for_stream_implementers\">API for Stream Implementers</a>.</p>\n",
          "miscs": [
            {
              "textRaw": "Writable Streams",
              "name": "writable_streams",
              "desc": "<p>Writable streams are an abstraction for a <em>destination</em> to which data is\nwritten.</p>\n<p>Examples of <a href=\"#stream_class_stream_writable\">Writable</a> streams include:</p>\n<ul>\n<li><a href=\"http.html#http_class_http_clientrequest\">HTTP requests, on the client</a></li>\n<li><a href=\"http.html#http_class_http_serverresponse\">HTTP responses, on the server</a></li>\n<li><a href=\"fs.html#fs_class_fs_writestream\">fs write streams</a></li>\n<li><a href=\"zlib.html\">zlib streams</a></li>\n<li><a href=\"crypto.html\">crypto streams</a></li>\n<li><a href=\"net.html#net_class_net_socket\">TCP sockets</a></li>\n<li><a href=\"child_process.html#child_process_child_stdin\">child process stdin</a></li>\n<li><a href=\"process.html#process_process_stdout\"><code>process.stdout</code></a>, <a href=\"process.html#process_process_stderr\"><code>process.stderr</code></a></li>\n</ul>\n<p><em>Note</em>: Some of these examples are actually <a href=\"#stream_class_stream_duplex\">Duplex</a> streams that implement\nthe <a href=\"#stream_class_stream_writable\">Writable</a> interface.</p>\n<p>All <a href=\"#stream_class_stream_writable\">Writable</a> streams implement the interface defined by the\n<code>stream.Writable</code> class.</p>\n<p>While specific instances of <a href=\"#stream_class_stream_writable\">Writable</a> streams may differ in various ways,\nall Writable streams follow the same fundamental usage pattern as illustrated\nin the example below:</p>\n<pre><code class=\"lang-js\">const myStream = getWritableStreamSomehow();\nmyStream.write(&#39;some data&#39;);\nmyStream.write(&#39;some more data&#39;);\nmyStream.end(&#39;done writing data&#39;);\n</code></pre>\n",
              "classes": [
                {
                  "textRaw": "Class: stream.Writable",
                  "type": "class",
                  "name": "stream.Writable",
                  "meta": {
                    "added": [
                      "v0.9.4"
                    ]
                  },
                  "events": [
                    {
                      "textRaw": "Event: 'close'",
                      "type": "event",
                      "name": "close",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "desc": "<p>The <code>&#39;close&#39;</code> event is emitted when the stream and any of its underlying\nresources (a file descriptor, for example) have been closed. The event indicates\nthat no more events will be emitted, and no further computation will occur.</p>\n<p>Not all Writable streams will emit the <code>&#39;close&#39;</code> event.</p>\n",
                      "params": []
                    },
                    {
                      "textRaw": "Event: 'drain'",
                      "type": "event",
                      "name": "drain",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "desc": "<p>If a call to <a href=\"#stream_writable_write_chunk_encoding_callback\"><code>stream.write(chunk)</code></a> returns <code>false</code>, the\n<code>&#39;drain&#39;</code> event will be emitted when it is appropriate to resume writing data\nto the stream.</p>\n<pre><code class=\"lang-js\">// Write the data to the supplied writable stream one million times.\n// Be attentive to back-pressure.\nfunction writeOneMillionTimes(writer, data, encoding, callback) {\n  let i = 1000000;\n  write();\n  function write() {\n    var ok = true;\n    do {\n      i--;\n      if (i === 0) {\n        // last time!\n        writer.write(data, encoding, callback);\n      } else {\n        // see if we should continue, or wait\n        // don&#39;t pass the callback, because we&#39;re not done yet.\n        ok = writer.write(data, encoding);\n      }\n    } while (i &gt; 0 &amp;&amp; ok);\n    if (i &gt; 0) {\n      // had to stop early!\n      // write some more once it drains\n      writer.once(&#39;drain&#39;, write);\n    }\n  }\n}\n</code></pre>\n",
                      "params": []
                    },
                    {
                      "textRaw": "Event: 'error'",
                      "type": "event",
                      "name": "error",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "params": [],
                      "desc": "<p>The <code>&#39;error&#39;</code> event is emitted if an error occurred while writing or piping\ndata. The listener callback is passed a single <code>Error</code> argument when called.</p>\n<p><em>Note</em>: The stream is not closed when the <code>&#39;error&#39;</code> event is emitted.</p>\n"
                    },
                    {
                      "textRaw": "Event: 'finish'",
                      "type": "event",
                      "name": "finish",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "desc": "<p>The <code>&#39;finish&#39;</code> event is emitted after the <a href=\"#stream_writable_end_chunk_encoding_callback\"><code>stream.end()</code></a> method\nhas been called, and all data has been flushed to the underlying system.</p>\n<pre><code class=\"lang-js\">const writer = getWritableStreamSomehow();\nfor (var i = 0; i &lt; 100; i ++) {\n  writer.write(&#39;hello, #${i}!\\n&#39;);\n}\nwriter.end(&#39;This is the end\\n&#39;);\nwriter.on(&#39;finish&#39;, () =&gt; {\n  console.error(&#39;All writes are now complete.&#39;);\n});\n</code></pre>\n",
                      "params": []
                    },
                    {
                      "textRaw": "Event: 'pipe'",
                      "type": "event",
                      "name": "pipe",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "params": [],
                      "desc": "<p>The <code>&#39;pipe&#39;</code> event is emitted when the <a href=\"#stream_readable_pipe_destination_options\"><code>stream.pipe()</code></a> method is called on\na readable stream, adding this writable to its set of destinations.</p>\n<pre><code class=\"lang-js\">const writer = getWritableStreamSomehow();\nconst reader = getReadableStreamSomehow();\nwriter.on(&#39;pipe&#39;, (src) =&gt; {\n  console.error(&#39;something is piping into the writer&#39;);\n  assert.equal(src, reader);\n});\nreader.pipe(writer);\n</code></pre>\n"
                    },
                    {
                      "textRaw": "Event: 'unpipe'",
                      "type": "event",
                      "name": "unpipe",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "params": [],
                      "desc": "<p>The <code>&#39;unpipe&#39;</code> event is emitted when the <a href=\"#stream_readable_unpipe_destination\"><code>stream.unpipe()</code></a> method is called\non a <a href=\"#stream_class_stream_readable\">Readable</a> stream, removing this <a href=\"#stream_class_stream_writable\">Writable</a> from its set of\ndestinations.</p>\n<pre><code class=\"lang-js\">const writer = getWritableStreamSomehow();\nconst reader = getReadableStreamSomehow();\nwriter.on(&#39;unpipe&#39;, (src) =&gt; {\n  console.error(&#39;Something has stopped piping into the writer.&#39;);\n  assert.equal(src, reader);\n});\nreader.pipe(writer);\nreader.unpipe(writer);\n</code></pre>\n"
                    }
                  ],
                  "methods": [
                    {
                      "textRaw": "writable.cork()",
                      "type": "method",
                      "name": "cork",
                      "meta": {
                        "added": [
                          "v0.11.2"
                        ]
                      },
                      "desc": "<p>The <code>writable.cork()</code> method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the <a href=\"#stream_writable_uncork\"><code>stream.uncork()</code></a> or\n<a href=\"#stream_writable_end_chunk_encoding_callback\"><code>stream.end()</code></a> methods are called.</p>\n<p>The primary intent of <code>writable.cork()</code> is to avoid a situation where writing\nmany small chunks of data to a stream do not cause a backup in the internal\nbuffer that would have an adverse impact on performance. In such situations,\nimplementations that implement the <code>writable._writev()</code> method can perform\nbuffered writes in a more optimized manner.</p>\n",
                      "signatures": [
                        {
                          "params": []
                        }
                      ]
                    },
                    {
                      "textRaw": "writable.end([chunk][, encoding][, callback])",
                      "type": "method",
                      "name": "end",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "signatures": [
                        {
                          "params": [
                            {
                              "textRaw": "`chunk` {String|Buffer|any} Optional data to write. For streams not operating in object mode, `chunk` must be a string or a `Buffer`. For object mode streams, `chunk` may be any JavaScript value other than `null`. ",
                              "name": "chunk",
                              "type": "String|Buffer|any",
                              "desc": "Optional data to write. For streams not operating in object mode, `chunk` must be a string or a `Buffer`. For object mode streams, `chunk` may be any JavaScript value other than `null`.",
                              "optional": true
                            },
                            {
                              "textRaw": "`encoding` {String} The encoding, if `chunk` is a String ",
                              "name": "encoding",
                              "type": "String",
                              "desc": "The encoding, if `chunk` is a String",
                              "optional": true
                            },
                            {
                              "textRaw": "`callback` {Function} Optional callback for when the stream is finished ",
                              "name": "callback",
                              "type": "Function",
                              "desc": "Optional callback for when the stream is finished",
                              "optional": true
                            }
                          ]
                        },
                        {
                          "params": [
                            {
                              "name": "chunk",
                              "optional": true
                            },
                            {
                              "name": "encoding",
                              "optional": true
                            },
                            {
                              "name": "callback",
                              "optional": true
                            }
                          ]
                        }
                      ],
                      "desc": "<p>Calling the <code>writable.end()</code> method signals that no more data will be written\nto the <a href=\"#stream_class_stream_writable\">Writable</a>. The optional <code>chunk</code> and <code>encoding</code> arguments allow one\nfinal additional chunk of data to be written immediately before closing the\nstream. If provided, the optional <code>callback</code> function is attached as a listener\nfor the <a href=\"#stream_event_finish\"><code>&#39;finish&#39;</code></a> event.</p>\n<p>Calling the <a href=\"#stream_writable_write_chunk_encoding_callback\"><code>stream.write()</code></a> method after calling\n<a href=\"#stream_writable_end_chunk_encoding_callback\"><code>stream.end()</code></a> will raise an error.</p>\n<pre><code class=\"lang-js\">// write &#39;hello, &#39; and then end with &#39;world!&#39;\nconst file = fs.createWriteStream(&#39;example.txt&#39;);\nfile.write(&#39;hello, &#39;);\nfile.end(&#39;world!&#39;);\n// writing more now is not allowed!\n</code></pre>\n"
                    },
                    {
                      "textRaw": "writable.setDefaultEncoding(encoding)",
                      "type": "method",
                      "name": "setDefaultEncoding",
                      "meta": {
                        "added": [
                          "v0.11.15"
                        ]
                      },
                      "signatures": [
                        {
                          "return": {
                            "textRaw": "Returns: `this` ",
                            "name": "return",
                            "desc": "`this`"
                          },
                          "params": [
                            {
                              "textRaw": "`encoding` {String} The new default encoding ",
                              "name": "encoding",
                              "type": "String",
                              "desc": "The new default encoding"
                            }
                          ]
                        },
                        {
                          "params": [
                            {
                              "name": "encoding"
                            }
                          ]
                        }
                      ],
                      "desc": "<p>The <code>writable.setDefaultEncoding()</code> method sets the default <code>encoding</code> for a\n<a href=\"#stream_class_stream_writable\">Writable</a> stream.</p>\n"
                    },
                    {
                      "textRaw": "writable.uncork()",
                      "type": "method",
                      "name": "uncork",
                      "meta": {
                        "added": [
                          "v0.11.2"
                        ]
                      },
                      "desc": "<p>The <code>writable.uncork()</code> method flushes all data buffered since\n<a href=\"#stream_writable_cork\"><code>stream.cork()</code></a> was called.</p>\n<p>When using <code>writable.cork()</code> and <code>writable.uncork()</code> to manage the buffering\nof writes to a stream, it is recommended that calls to <code>writable.uncork()</code> be\ndeferred using <code>process.nextTick()</code>. Doing so allows batching of all\n<code>writable.write()</code> calls that occur within a given Node.js event loop phase.</p>\n<pre><code class=\"lang-js\">stream.cork();\nstream.write(&#39;some &#39;);\nstream.write(&#39;data &#39;);\nprocess.nextTick(() =&gt; stream.uncork());\n</code></pre>\n<p>If the <code>writable.cork()</code> method is called multiple times on a stream, the same\nnumber of calls to <code>writable.uncork()</code> must be called to flush the buffered\ndata.</p>\n<pre><code class=\"lang-js\">stream.cork();\nstream.write(&#39;some &#39;);\nstream.cork();\nstream.write(&#39;data &#39;);\nprocess.nextTick(() =&gt; {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n</code></pre>\n",
                      "signatures": [
                        {
                          "params": []
                        }
                      ]
                    },
                    {
                      "textRaw": "writable.write(chunk[, encoding][, callback])",
                      "type": "method",
                      "name": "write",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "signatures": [
                        {
                          "return": {
                            "textRaw": "Returns: {Boolean} `false` if the stream wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`. ",
                            "name": "return",
                            "type": "Boolean",
                            "desc": "`false` if the stream wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`."
                          },
                          "params": [
                            {
                              "textRaw": "`chunk` {String|Buffer} The data to write ",
                              "name": "chunk",
                              "type": "String|Buffer",
                              "desc": "The data to write"
                            },
                            {
                              "textRaw": "`encoding` {String} The encoding, if `chunk` is a String ",
                              "name": "encoding",
                              "type": "String",
                              "desc": "The encoding, if `chunk` is a String",
                              "optional": true
                            },
                            {
                              "textRaw": "`callback` {Function} Callback for when this chunk of data is flushed ",
                              "name": "callback",
                              "type": "Function",
                              "desc": "Callback for when this chunk of data is flushed",
                              "optional": true
                            }
                          ]
                        },
                        {
                          "params": [
                            {
                              "name": "chunk"
                            },
                            {
                              "name": "encoding",
                              "optional": true
                            },
                            {
                              "name": "callback",
                              "optional": true
                            }
                          ]
                        }
                      ],
                      "desc": "<p>The <code>writable.write()</code> method writes some data to the stream, and calls the\nsupplied <code>callback</code> once the data has been fully handled. If an error\noccurs, the <code>callback</code> <em>may or may not</em> be called with the error as its\nfirst argument. To reliably detect write errors, add a listener for the\n<code>&#39;error&#39;</code> event.</p>\n<p>The return value is <code>true</code> if the internal buffer does not exceed\n<code>highWaterMark</code> configured when the stream was created after admitting <code>chunk</code>.\nIf <code>false</code> is returned, further attempts to write data to the stream should\nstop until the <a href=\"#stream_event_drain\"><code>&#39;drain&#39;</code></a> event is emitted. However, the <code>false</code> return\nvalue is only advisory and the writable stream will unconditionally accept and\nbuffer <code>chunk</code> even if it has not not been allowed to drain.</p>\n<p>A Writable stream in object mode will always ignore the <code>encoding</code> argument.</p>\n"
                    }
                  ]
                }
              ],
              "type": "misc",
              "displayName": "Writable Streams"
            },
            {
              "textRaw": "Readable Streams",
              "name": "readable_streams",
              "desc": "<p>Readable streams are an abstraction for a <em>source</em> from which data is\nconsumed.</p>\n<p>Examples of Readable streams include:</p>\n<ul>\n<li><a href=\"http.html#http_class_http_incomingmessage\">HTTP responses, on the client</a></li>\n<li><a href=\"http.html#http_class_http_incomingmessage\">HTTP requests, on the server</a></li>\n<li><a href=\"fs.html#fs_class_fs_readstream\">fs read streams</a></li>\n<li><a href=\"zlib.html\">zlib streams</a></li>\n<li><a href=\"crypto.html\">crypto streams</a></li>\n<li><a href=\"net.html#net_class_net_socket\">TCP sockets</a></li>\n<li><a href=\"child_process.html#child_process_child_stdout\">child process stdout and stderr</a></li>\n<li><a href=\"process.html#process_process_stdin\"><code>process.stdin</code></a></li>\n</ul>\n<p>All <a href=\"#stream_class_stream_readable\">Readable</a> streams implement the interface defined by the\n<code>stream.Readable</code> class.</p>\n",
              "modules": [
                {
                  "textRaw": "Two Modes",
                  "name": "two_modes",
                  "desc": "<p>Readable streams effectively operate in one of two modes: flowing and paused.</p>\n<p>When in flowing mode, data is read from the underlying system automatically\nand provided to an application as quickly as possible using events via the\n<a href=\"events.html#events_class_eventemitter\"><code>EventEmitter</code></a> interface.</p>\n<p>In paused mode, the <a href=\"#stream_readable_read_size\"><code>stream.read()</code></a> method must be called\nexplicitly to read chunks of data from the stream.</p>\n<p>All <a href=\"#stream_class_stream_readable\">Readable</a> streams begin in paused mode but can be switched to flowing\nmode in one of the following ways:</p>\n<ul>\n<li>Adding a <a href=\"#stream_event_data\"><code>&#39;data&#39;</code></a> event handler.</li>\n<li>Calling the <a href=\"#stream_readable_resume\"><code>stream.resume()</code></a> method.</li>\n<li>Calling the <a href=\"#stream_readable_pipe_destination_options\"><code>stream.pipe()</code></a> method to send the data to a <a href=\"#stream_class_stream_writable\">Writable</a>.</li>\n</ul>\n<p>The Readable can switch back to paused mode using one of the following:</p>\n<ul>\n<li>If there are no pipe destinations, by calling the\n<a href=\"#stream_readable_pause\"><code>stream.pause()</code></a> method.</li>\n<li>If there are pipe destinations, by removing any <a href=\"#stream_event_data\"><code>&#39;data&#39;</code></a> event\nhandlers, and removing all pipe destinations by calling the\n<a href=\"#stream_readable_unpipe_destination\"><code>stream.unpipe()</code></a> method.</li>\n</ul>\n<p>The important concept to remember is that a Readable will not generate data\nuntil a mechanism for either consuming or ignoring that data is provided. If\nthe consuming mechanism is disabled or taken away, the Readable will <em>attempt</em>\nto stop generating the data.</p>\n<p><em>Note</em>: For backwards compatibility reasons, removing <a href=\"#stream_event_data\"><code>&#39;data&#39;</code></a> event\nhandlers will <strong>not</strong> automatically pause the stream. Also, if there are piped\ndestinations, then calling <a href=\"#stream_readable_pause\"><code>stream.pause()</code></a> will not guarantee\nthat the stream will <em>remain</em> paused once those destinations drain and ask for\nmore data.</p>\n<p><em>Note</em>: If a <a href=\"#stream_class_stream_readable\">Readable</a> is switched into flowing mode and there are no\nconsumers available handle the data, that data will be lost. This can occur,\nfor instance, when the <code>readable.resume()</code> method is called without a listener\nattached to the <code>&#39;data&#39;</code> event, or when a <code>&#39;data&#39;</code> event handler is removed\nfrom the stream.</p>\n",
                  "type": "module",
                  "displayName": "Two Modes"
                },
                {
                  "textRaw": "Three States",
                  "name": "three_states",
                  "desc": "<p>The &quot;two modes&quot; of operation for a Readable stream are a simplified abstraction\nfor the more complicated internal state management that is happening within the\nReadable stream implementation.</p>\n<p>Specifically, at any given point in time, every Readable is in one of three\npossible states:</p>\n<ul>\n<li><code>readable._readableState.flowing = null</code></li>\n<li><code>readable._readableState.flowing = false</code></li>\n<li><code>readable._readableState.flowing = true</code></li>\n</ul>\n<p>When <code>readable._readableState.flowing</code> is <code>null</code>, no mechanism for consuming the\nstreams data is provided so the stream will not generate its data.</p>\n<p>Attaching a listener for the <code>&#39;data&#39;</code> event, calling the <code>readable.pipe()</code>\nmethod, or calling the <code>readable.resume()</code> method will switch\n<code>readable._readableState.flowing</code> to <code>true</code>, causing the Readable to begin\nactively emitting events as data is generated.</p>\n<p>Calling <code>readable.pause()</code>, <code>readable.unpipe()</code>, or receiving &quot;back pressure&quot;\nwill cause the <code>readable._readableState.flowing</code> to be set as <code>false</code>,\ntemporarily halting the flowing of events but <em>not</em> halting the generation of\ndata.</p>\n<p>While <code>readable._readableState.flowing</code> is <code>false</code>, data may be accumulating\nwithin the streams internal buffer.</p>\n",
                  "type": "module",
                  "displayName": "Three States"
                },
                {
                  "textRaw": "Choose One",
                  "name": "choose_one",
                  "desc": "<p>The Readable stream API evolved across multiple Node.js versions and provides\nmultiple methods of consuming stream data. In general, developers should choose\n<em>one</em> of the methods of consuming data and <em>should never</em> use multiple methods\nto consume data from a single stream.</p>\n<p>Use of the <code>readable.pipe()</code> method is recommended for most users as it has been\nimplemented to provide the easiest way of consuming stream data. Developers that\nrequire more fine-grained control over the transfer and generation of data can\nuse the <a href=\"events.html#events_class_eventemitter\"><code>EventEmitter</code></a> and <code>readable.pause()</code>/<code>readable.resume()</code> APIs.</p>\n",
                  "type": "module",
                  "displayName": "Choose One"
                }
              ],
              "classes": [
                {
                  "textRaw": "Class: stream.Readable",
                  "type": "class",
                  "name": "stream.Readable",
                  "meta": {
                    "added": [
                      "v0.9.4"
                    ]
                  },
                  "events": [
                    {
                      "textRaw": "Event: 'close'",
                      "type": "event",
                      "name": "close",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "desc": "<p>The <code>&#39;close&#39;</code> event is emitted when the stream and any of its underlying\nresources (a file descriptor, for example) have been closed. The event indicates\nthat no more events will be emitted, and no further computation will occur.</p>\n<p>Not all <a href=\"#stream_class_stream_readable\">Readable</a> streams will emit the <code>&#39;close&#39;</code> event.</p>\n",
                      "params": []
                    },
                    {
                      "textRaw": "Event: 'data'",
                      "type": "event",
                      "name": "data",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "params": [],
                      "desc": "<p>The <code>&#39;data&#39;</code> event is emitted whenever the stream is relinquishing ownership of\na chunk of data to a consumer. This may occur whenever the stream is switched\nin flowing mode by calling <code>readable.pipe()</code>, <code>readable.resume()</code>, or by\nattaching a listener callback to the <code>&#39;data&#39;</code> event. The <code>&#39;data&#39;</code> event will\nalso be emitted whenever the <code>readable.read()</code> method is called and a chunk of\ndata is available to be returned.</p>\n<p>Attaching a <code>&#39;data&#39;</code> event listener to a stream that has not been explicitly\npaused will switch the stream into flowing mode. Data will then be passed as\nsoon as it is available.</p>\n<p>The listener callback will be passed the chunk of data as a string if a default\nencoding has been specified for the stream using the\n<code>readable.setEncoding()</code> method; otherwise the data will be passed as a\n<code>Buffer</code>.</p>\n<pre><code class=\"lang-js\">const readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  console.log(`Received ${chunk.length} bytes of data.`);\n});\n</code></pre>\n"
                    },
                    {
                      "textRaw": "Event: 'end'",
                      "type": "event",
                      "name": "end",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "desc": "<p>The <code>&#39;end&#39;</code> event is emitted when there is no more data to be consumed from\nthe stream.</p>\n<p><em>Note</em>: The <code>&#39;end&#39;</code> event <strong>will not be emitted</strong> unless the data is\ncompletely consumed. This can be accomplished by switching the stream into\nflowing mode, or by calling <a href=\"#stream_readable_read_size\"><code>stream.read()</code></a> repeatedly until\nall data has been consumed.</p>\n<pre><code class=\"lang-js\">const readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  console.log(`Received ${chunk.length} bytes of data.`);\n});\nreadable.on(&#39;end&#39;, () =&gt; {\n  console.log(&#39;There will be no more data.&#39;);\n});\n</code></pre>\n",
                      "params": []
                    },
                    {
                      "textRaw": "Event: 'error'",
                      "type": "event",
                      "name": "error",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "params": [],
                      "desc": "<p>The <code>&#39;error&#39;</code> event may be emitted by a Readable implementation at any time.\nTypically, this may occur if the underlying stream in unable to generate data\ndue to an underlying internal failure, or when a stream implementation attempts\nto push an invalid chunk of data.</p>\n<p>The listener callback will be passed a single <code>Error</code> object.</p>\n"
                    },
                    {
                      "textRaw": "Event: 'readable'",
                      "type": "event",
                      "name": "readable",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "desc": "<p>The <code>&#39;readable&#39;</code> event is emitted when there is data available to be read from\nthe stream. In some cases, attaching a listener for the <code>&#39;readable&#39;</code> event will\ncause some amount of data to be read into an internal buffer.</p>\n<pre><code class=\"lang-javascript\">const readable = getReadableStreamSomehow();\nreadable.on(&#39;readable&#39;, () =&gt; {\n  // there is some data to read now\n});\n</code></pre>\n<p>The <code>&#39;readable&#39;</code> event will also be emitted once the end of the stream data\nhas been reached but before the <code>&#39;end&#39;</code> event is emitted.</p>\n<p>Effectively, the <code>&#39;readable&#39;</code> event indicates that the stream has new\ninformation: either new data is available or the end of the stream has been\nreached. In the former case, <a href=\"#stream_readable_read_size\"><code>stream.read()</code></a> will return the\navailable data. In the latter case, <a href=\"#stream_readable_read_size\"><code>stream.read()</code></a> will return\n<code>null</code>. For instance, in the following example, <code>foo.txt</code> is an empty file:</p>\n<pre><code class=\"lang-js\">const fs = require(&#39;fs&#39;);\nconst rr = fs.createReadStream(&#39;foo.txt&#39;);\nrr.on(&#39;readable&#39;, () =&gt; {\n  console.log(&#39;readable:&#39;, rr.read());\n});\nrr.on(&#39;end&#39;, () =&gt; {\n  console.log(&#39;end&#39;);\n});\n</code></pre>\n<p>The output of running this script is:</p>\n<pre><code class=\"lang-txt\">$ node test.js\nreadable: null\nend\n</code></pre>\n<p><em>Note</em>: In general, the <code>readable.pipe()</code> and <code>&#39;data&#39;</code> event mechanisms are\npreferred over the use of the <code>&#39;readable&#39;</code> event.</p>\n",
                      "params": []
                    }
                  ],
                  "methods": [
                    {
                      "textRaw": "readable.isPaused()",
                      "type": "method",
                      "name": "isPaused",
                      "desc": "<!--\nadded: v0.11.14\n-->\n<ul>\n<li>Returns: {Boolean}</li>\n</ul>\n<p>The <code>readable.isPaused()</code> method returns the current operating state of the\nReadable. This is used primarily by the mechanism that underlies the\n<code>readable.pipe()</code> method. In most typical cases, there will be no reason to\nuse this method directly.</p>\n<pre><code class=\"lang-js\">const readable = new stream.Readable\n\nreadable.isPaused() // === false\nreadable.pause()\nreadable.isPaused() // === true\nreadable.resume()\nreadable.isPaused() // === false\n</code></pre>\n",
                      "signatures": [
                        {
                          "params": []
                        }
                      ]
                    },
                    {
                      "textRaw": "readable.pause()",
                      "type": "method",
                      "name": "pause",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "signatures": [
                        {
                          "return": {
                            "textRaw": "Returns: `this` ",
                            "name": "return",
                            "desc": "`this`"
                          },
                          "params": []
                        },
                        {
                          "params": []
                        }
                      ],
                      "desc": "<p>The <code>readable.pause()</code> method will cause a stream in flowing mode to stop\nemitting <a href=\"#stream_event_data\"><code>&#39;data&#39;</code></a> events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.</p>\n<pre><code class=\"lang-js\">const readable = getReadableStreamSomehow();\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log(&#39;There will be no additional data for 1 second.&#39;);\n  setTimeout(() =&gt; {\n    console.log(&#39;Now data will start flowing again.&#39;);\n    readable.resume();\n  }, 1000);\n});\n</code></pre>\n"
                    },
                    {
                      "textRaw": "readable.pipe(destination[, options])",
                      "type": "method",
                      "name": "pipe",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "signatures": [
                        {
                          "params": [
                            {
                              "textRaw": "`destination` {stream.Writable} The destination for writing data ",
                              "name": "destination",
                              "type": "stream.Writable",
                              "desc": "The destination for writing data"
                            },
                            {
                              "textRaw": "`options` {Object} Pipe options ",
                              "options": [
                                {
                                  "textRaw": "`end` {Boolean} End the writer when the reader ends. Defaults to `true`. ",
                                  "name": "end",
                                  "type": "Boolean",
                                  "desc": "End the writer when the reader ends. Defaults to `true`."
                                }
                              ],
                              "name": "options",
                              "type": "Object",
                              "desc": "Pipe options",
                              "optional": true
                            }
                          ]
                        },
                        {
                          "params": [
                            {
                              "name": "destination"
                            },
                            {
                              "name": "options",
                              "optional": true
                            }
                          ]
                        }
                      ],
                      "desc": "<p>The <code>readable.pipe()</code> method attaches a <a href=\"#stream_class_stream_writable\">Writable</a> stream to the <code>readable</code>,\ncausing it to switch automatically into flowing mode and push all of its data\nto the attached <a href=\"#stream_class_stream_writable\">Writable</a>. The flow of data will be automatically managed so\nthat the destination Writable stream is not overwhelmed by a faster Readable\nstream.</p>\n<p>The following example pipes all of the data from the <code>readable</code> into a file\nnamed <code>file.txt</code>:</p>\n<pre><code class=\"lang-js\">const readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream(&#39;file.txt&#39;);\n// All the data from readable goes into &#39;file.txt&#39;\nreadable.pipe(writable);\n</code></pre>\n<p>It is possible to attach multiple Writable streams to a single Readable stream.</p>\n<p>The <code>readable.pipe()</code> method returns a reference to the <em>destination</em> stream\nmaking it possible to set up chains of piped streams:</p>\n<pre><code class=\"lang-js\">const r = fs.createReadStream(&#39;file.txt&#39;);\nconst z = zlib.createGzip();\nconst w = fs.createWriteStream(&#39;file.txt.gz&#39;);\nr.pipe(z).pipe(w);\n</code></pre>\n<p>By default, <a href=\"#stream_writable_end_chunk_encoding_callback\"><code>stream.end()</code></a> is called on the destination Writable\nstream when the source Readable stream emits <a href=\"#stream_event_end\"><code>&#39;end&#39;</code></a>, so that the\ndestination is no longer writable. To disable this default behavior, the <code>end</code>\noption can be passed as <code>false</code>, causing the destination stream to remain open,\nas illustrated in the following example:</p>\n<pre><code class=\"lang-js\">reader.pipe(writer, { end: false });\nreader.on(&#39;end&#39;, () =&gt; {\n  writer.end(&#39;Goodbye\\n&#39;);\n});\n</code></pre>\n<p>One important caveat is that if the Readable stream emits an error during\nprocessing, the Writable destination <em>is not closed</em> automatically. If an\nerror occurs, it will be necessary to <em>manually</em> close each stream in order\nto prevent memory leaks.</p>\n<p><em>Note</em>: The <a href=\"process.html#process_process_stderr\"><code>process.stderr</code></a> and <a href=\"process.html#process_process_stdout\"><code>process.stdout</code></a> Writable streams are\nnever closed until the Node.js process exits, regardless of the specified\noptions.</p>\n"
                    },
                    {
                      "textRaw": "readable.read([size])",
                      "type": "method",
                      "name": "read",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "signatures": [
                        {
                          "return": {
                            "textRaw": "Return {String|Buffer|Null} ",
                            "name": "return",
                            "type": "String|Buffer|Null"
                          },
                          "params": [
                            {
                              "textRaw": "`size` {Number} Optional argument to specify how much data to read. ",
                              "name": "size",
                              "type": "Number",
                              "desc": "Optional argument to specify how much data to read.",
                              "optional": true
                            }
                          ]
                        },
                        {
                          "params": [
                            {
                              "name": "size",
                              "optional": true
                            }
                          ]
                        }
                      ],
                      "desc": "<p>The <code>readable.read()</code> method pulls some data out of the internal buffer and\nreturns it. If no data available to be read, <code>null</code> is returned. By default,\nthe data will be returned as a <code>Buffer</code> object unless an encoding has been\nspecified using the <code>readable.setEncoding()</code> method or the stream is operating\nin object mode.</p>\n<p>The optional <code>size</code> argument specifies a specific number of bytes to read. If\n<code>size</code> bytes are not available to be read, <code>null</code> will be returned <em>unless</em>\nthe stream has ended, in which case all of the data remaining in the internal\nbuffer will be returned (<em>even if it exceeds <code>size</code> bytes</em>).</p>\n<p>If the <code>size</code> argument is not specified, all of the data contained in the\ninternal buffer will be returned.</p>\n<p>The <code>readable.read()</code> method should only be called on Readable streams operating\nin paused mode. In flowing mode, <code>readable.read()</code> is called automatically until\nthe internal buffer is fully drained.</p>\n<pre><code class=\"lang-js\">const readable = getReadableStreamSomehow();\nreadable.on(&#39;readable&#39;, () =&gt; {\n  var chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log(`Received ${chunk.length} bytes of data.`);\n  }\n});\n</code></pre>\n<p>In general, it is recommended that developers avoid the use of the <code>&#39;readable&#39;</code>\nevent and the <code>readable.read()</code> method in favor of using either\n<code>readable.pipe()</code> or the <code>&#39;data&#39;</code> event.</p>\n<p>A Readable stream in object mode will always return a single item from\na call to <a href=\"#stream_readable_read_size\"><code>readable.read(size)</code></a>, regardless of the value of the\n<code>size</code> argument.</p>\n<p><em>Note:</em> If the <code>readable.read()</code> method returns a chunk of data, a <code>&#39;data&#39;</code>\nevent will also be emitted.</p>\n<p><em>Note</em>: Calling <a href=\"#stream_readable_read_size\"><code>stream.read([size])</code></a> after the <a href=\"#stream_event_end\"><code>&#39;end&#39;</code></a>\nevent has been emitted will return <code>null</code>. No runtime error will be raised.</p>\n"
                    },
                    {
                      "textRaw": "readable.resume()",
                      "type": "method",
                      "name": "resume",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "signatures": [
                        {
                          "return": {
                            "textRaw": "Returns: `this` ",
                            "name": "return",
                            "desc": "`this`"
                          },
                          "params": []
                        },
                        {
                          "params": []
                        }
                      ],
                      "desc": "<p>The <code>readable.resume()</code> method causes an explicitly paused Readable stream to\nresume emitting <a href=\"#stream_event_data\"><code>&#39;data&#39;</code></a> events, switching the stream into flowing mode.</p>\n<p>The <code>readable.resume()</code> method can be used to fully consume the data from a\nstream without actually processing any of that data as illustrated in the\nfollowing example:</p>\n<pre><code class=\"lang-js\">getReadableStreamSomehow()\n  .resume()\n  .on(&#39;end&#39;, () =&gt; {\n    console.log(&#39;Reached the end, but did not read anything.&#39;);\n  });\n</code></pre>\n"
                    },
                    {
                      "textRaw": "readable.setEncoding(encoding)",
                      "type": "method",
                      "name": "setEncoding",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "signatures": [
                        {
                          "return": {
                            "textRaw": "Returns: `this` ",
                            "name": "return",
                            "desc": "`this`"
                          },
                          "params": [
                            {
                              "textRaw": "`encoding` {String} The encoding to use. ",
                              "name": "encoding",
                              "type": "String",
                              "desc": "The encoding to use."
                            }
                          ]
                        },
                        {
                          "params": [
                            {
                              "name": "encoding"
                            }
                          ]
                        }
                      ],
                      "desc": "<p>The <code>readable.setEncoding()</code> method sets the default character encoding for\ndata read from the Readable stream.</p>\n<p>Setting an encoding causes the stream data\nto be returned as string of the specified encoding rather than as <code>Buffer</code>\nobjects. For instance, calling <code>readable.setEncoding(&#39;utf8&#39;)</code> will cause the\noutput data will be interpreted as UTF-8 data, and passed as strings. Calling\n<code>readable.setEncoding(&#39;hex&#39;)</code> will cause the data to be encoded in hexadecimal\nstring format.</p>\n<p>The Readable stream will properly handle multi-byte characters delivered through\nthe stream that would otherwise become improperly decoded if simply pulled from\nthe stream as <code>Buffer</code> objects.</p>\n<p>Encoding can be disabled by calling <code>readable.setEncoding(null)</code>. This approach\nis useful when working with binary data or with large multi-byte strings spread\nout over multiple chunks.</p>\n<pre><code class=\"lang-js\">const readable = getReadableStreamSomehow();\nreadable.setEncoding(&#39;utf8&#39;);\nreadable.on(&#39;data&#39;, (chunk) =&gt; {\n  assert.equal(typeof chunk, &#39;string&#39;);\n  console.log(&#39;got %d characters of string data&#39;, chunk.length);\n});\n</code></pre>\n"
                    },
                    {
                      "textRaw": "readable.unpipe([destination])",
                      "type": "method",
                      "name": "unpipe",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "signatures": [
                        {
                          "params": [
                            {
                              "textRaw": "`destination` {stream.Writable} Optional specific stream to unpipe ",
                              "name": "destination",
                              "type": "stream.Writable",
                              "desc": "Optional specific stream to unpipe",
                              "optional": true
                            }
                          ]
                        },
                        {
                          "params": [
                            {
                              "name": "destination",
                              "optional": true
                            }
                          ]
                        }
                      ],
                      "desc": "<p>The <code>readable.unpipe()</code> method detaches a Writable stream previously attached\nusing the <a href=\"#stream_readable_pipe_destination_options\"><code>stream.pipe()</code></a> method.</p>\n<p>If the <code>destination</code> is not specified, then <em>all</em> pipes are detached.</p>\n<p>If the <code>destination</code> is specified, but no pipe is set up for it, then\nthe method does nothing.</p>\n<pre><code class=\"lang-js\">const readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream(&#39;file.txt&#39;);\n// All the data from readable goes into &#39;file.txt&#39;,\n// but only for the first second\nreadable.pipe(writable);\nsetTimeout(() =&gt; {\n  console.log(&#39;Stop writing to file.txt&#39;);\n  readable.unpipe(writable);\n  console.log(&#39;Manually close the file stream&#39;);\n  writable.end();\n}, 1000);\n</code></pre>\n"
                    },
                    {
                      "textRaw": "readable.unshift(chunk)",
                      "type": "method",
                      "name": "unshift",
                      "meta": {
                        "added": [
                          "v0.9.11"
                        ]
                      },
                      "signatures": [
                        {
                          "params": [
                            {
                              "textRaw": "`chunk` {Buffer|String} Chunk of data to unshift onto the read queue ",
                              "name": "chunk",
                              "type": "Buffer|String",
                              "desc": "Chunk of data to unshift onto the read queue"
                            }
                          ]
                        },
                        {
                          "params": [
                            {
                              "name": "chunk"
                            }
                          ]
                        }
                      ],
                      "desc": "<p>The <code>readable.unshift()</code> method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to &quot;un-consume&quot; some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.</p>\n<p><em>Note</em>: The <code>stream.unshift(chunk)</code> method cannot be called after the\n<a href=\"#stream_event_end\"><code>&#39;end&#39;</code></a> event has been emitted or a runtime error will be thrown.</p>\n<p>Developers using <code>stream.unshift()</code> often should consider switching to\nuse of a <a href=\"#stream_class_stream_transform\">Transform</a> stream instead. See the <a href=\"#stream_api_for_stream_implementers\">API for Stream Implementers</a>\nsection for more information.</p>\n<pre><code class=\"lang-js\">// Pull off a header delimited by \\n\\n\n// use unshift() if we get too much\n// Call the callback with (error, header, stream)\nconst StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;\nfunction parseHeader(stream, callback) {\n  stream.on(&#39;error&#39;, callback);\n  stream.on(&#39;readable&#39;, onReadable);\n  const decoder = new StringDecoder(&#39;utf8&#39;);\n  var header = &#39;&#39;;\n  function onReadable() {\n    var chunk;\n    while (null !== (chunk = stream.read())) {\n      var str = decoder.write(chunk);\n      if (str.match(/\\n\\n/)) {\n        // found the header boundary\n        var split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join(&#39;\\n\\n&#39;);\n        const buf = Buffer.from(remaining, &#39;utf8&#39;);\n        stream.removeListener(&#39;error&#39;, callback);\n        // set the readable listener before unshifting\n        stream.removeListener(&#39;readable&#39;, onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // now the body of the message can be read from the stream.\n        callback(null, header, stream);\n      } else {\n        // still reading the header.\n        header += str;\n      }\n    }\n  }\n}\n</code></pre>\n<p><em>Note</em>: Unlike <a href=\"#stream_readable_push_chunk_encoding\"><code>stream.push(chunk)</code></a>, <code>stream.unshift(chunk)</code>\nwill not end the reading process by resetting the internal reading state of the\nstream. This can cause unexpected results if <code>readable.unshift()</code> is called\nduring a read (i.e. from within a <a href=\"#stream_readable_read_size_1\"><code>stream._read()</code></a>\nimplementation on a custom stream). Following the call to <code>readable.unshift()</code>\nwith an immediate <a href=\"#stream_readable_push_chunk_encoding\"><code>stream.push(&#39;&#39;)</code></a> will reset the reading state\nappropriately, however it is best to simply avoid calling <code>readable.unshift()</code>\nwhile in the process of performing a read.</p>\n"
                    },
                    {
                      "textRaw": "readable.wrap(stream)",
                      "type": "method",
                      "name": "wrap",
                      "meta": {
                        "added": [
                          "v0.9.4"
                        ]
                      },
                      "signatures": [
                        {
                          "params": [
                            {
                              "textRaw": "`stream` {Stream} An \"old style\" readable stream ",
                              "name": "stream",
                              "type": "Stream",
                              "desc": "An \"old style\" readable stream"
                            }
                          ]
                        },
                        {
                          "params": [
                            {
                              "name": "stream"
                            }
                          ]
                        }
                      ],
                      "desc": "<p>Versions of Node.js prior to v0.10 had streams that did not implement the\nentire <code>stream</code> module API as it is currently defined. (See <a href=\"#stream_compatibility_with_older_node_js_versions\">Compatibility</a>\nfor more information.)</p>\n<p>When using an older Node.js library that emits <a href=\"#stream_event_data\"><code>&#39;data&#39;</code></a> events and has a\n<a href=\"#stream_readable_pause\"><code>stream.pause()</code></a> method that is advisory only, the\n<code>readable.wrap()</code> method can be used to create a <a href=\"#stream_class_stream_readable\">Readable</a> stream that uses\nthe old stream as its data source.</p>\n<p>It will rarely be necessary to use <code>readable.wrap()</code> but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.</p>\n<p>For example:</p>\n<pre><code class=\"lang-js\">const OldReader = require(&#39;./old-api-module.js&#39;).OldReader;\nconst Readable = require(&#39;stream&#39;).Readable;\nconst oreader = new OldReader;\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on(&#39;readable&#39;, () =&gt; {\n  myReader.read(); // etc.\n});\n</code></pre>\n"
                    }
                  ]
                }
              ],
              "type": "misc",
              "displayName": "Readable Streams"
            },
            {
              "textRaw": "Duplex and Transform Streams",
              "name": "duplex_and_transform_streams",
              "classes": [
                {
                  "textRaw": "Class: stream.Duplex",
                  "type": "class",
                  "name": "stream.Duplex",
                  "meta": {
                    "added": [
                      "v0.9.4"
                    ]
                  },
                  "desc": "<p>Duplex streams are streams that implement both the <a href=\"#stream_class_stream_readable\">Readable</a> and\n<a href=\"#stream_class_stream_writable\">Writable</a> interfaces.</p>\n<p>Examples of Duplex streams include:</p>\n<ul>\n<li><a href=\"net.html#net_class_net_socket\">TCP sockets</a></li>\n<li><a href=\"zlib.html\">zlib streams</a></li>\n<li><a href=\"crypto.html\">crypto streams</a></li>\n</ul>\n"
                },
                {
                  "textRaw": "Class: stream.Transform",
                  "type": "class",
                  "name": "stream.Transform",
                  "meta": {
                    "added": [
                      "v0.9.4"
                    ]
                  },
                  "desc": "<p>Transform streams are <a href=\"#stream_class_stream_duplex\">Duplex</a> streams where the output is in some way\nrelated to the input. Like all <a href=\"#stream_class_stream_duplex\">Duplex</a> streams, Transform streams\nimplement both the <a href=\"#stream_class_stream_readable\">Readable</a> and <a href=\"#stream_class_stream_writable\">Writable</a> interfaces.</p>\n<p>Examples of Transform streams include:</p>\n<ul>\n<li><a href=\"zlib.html\">zlib streams</a></li>\n<li><a href=\"crypto.html\">crypto streams</a></li>\n</ul>\n"
                }
              ],
              "type": "misc",
              "displayName": "Duplex and Transform Streams"
            }
          ]
        },
        {
          "textRaw": "API for Stream Implementers",
          "name": "API for Stream Implementers",
          "type": "misc",
          "desc": "<p>The <code>stream</code> module API has been designed to make it possible to easily\nimplement streams using JavaScript&#39;s prototypal inheritance model.</p>\n<p>First, a stream developer would declare a new JavaScript class that extends one\nof the four basic stream classes (<code>stream.Writable</code>, <code>stream.Readable</code>,\n<code>stream.Duplex</code>, or <code>stream.Transform</code>), making sure the call the appropriate\nparent class constructor:</p>\n<pre><code class=\"lang-js\">const Writable = require(&#39;stream&#39;).Writable;\n\nclass MyWritable extends Writable {\n  constructor(options) {\n    super(options);\n  }\n}\n</code></pre>\n<p>The new stream class must then implement one or more specific methods, depending\non the type of stream being created, as detailed in the chart below:</p>\n<table>\n  <thead>\n    <tr>\n      <th>\n        <p>Use-case</p>\n      </th>\n      <th>\n        <p>Class</p>\n      </th>\n      <th>\n        <p>Method(s) to implement</p>\n      </th>\n    </tr>\n  </thead>\n  <tr>\n    <td>\n      <p>Reading only</p>\n    </td>\n    <td>\n      <p><a href=\"#stream_class_stream_readable\">Readable</a></p>\n    </td>\n    <td>\n      <p><code><a href=\"#stream_readable_read_size_1\">_read</a></code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Writing only</p>\n    </td>\n    <td>\n      <p><a href=\"#stream_class_stream_writable\">Writable</a></p>\n    </td>\n    <td>\n      <p><code><a href=\"#stream_writable_write_chunk_encoding_callback_1\">_write</a></code>, <code><a href=\"#stream_writable_writev_chunks_callback\">_writev</a></code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Reading and writing</p>\n    </td>\n    <td>\n      <p><a href=\"#stream_class_stream_duplex\">Duplex</a></p>\n    </td>\n    <td>\n      <p><code><a href=\"#stream_readable_read_size_1\">_read</a></code>, <code><a href=\"#stream_writable_write_chunk_encoding_callback_1\">_write</a></code>, <code><a href=\"#stream_writable_writev_chunks_callback\">_writev</a></code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Operate on written data, then read the result</p>\n    </td>\n    <td>\n      <p><a href=\"#stream_class_stream_transform\">Transform</a></p>\n    </td>\n    <td>\n      <p><code><a href=\"#stream_transform_transform_chunk_encoding_callback\">_transform</a></code>, <code><a href=\"#stream_transform_flush_callback\">_flush</a></code></p>\n    </td>\n  </tr>\n</table>\n\n<p><em>Note</em>: The implementation code for a stream should <em>never</em> call the &quot;public&quot;\nmethods of a stream that are intended for use by consumers (as described in\nthe <a href=\"#stream_api_for_stream_consumers\">API for Stream Consumers</a> section). Doing so may lead to adverse\nside effects in application code consuming the stream.</p>\n",
          "miscs": [
            {
              "textRaw": "Simplified Construction",
              "name": "simplified_construction",
              "desc": "<p>For many simple cases, it is possible to construct a stream without relying on\ninheritance. This can be accomplished by directly creating instances of the\n<code>stream.Writable</code>, <code>stream.Readable</code>, <code>stream.Duplex</code> or <code>stream.Transform</code>\nobjects and passing appropriate methods as constructor options.</p>\n<p>For example:</p>\n<pre><code class=\"lang-js\">const Writable = require(&#39;stream&#39;).Writable;\n\nconst myWritable = new Writable({\n  write(chunk, encoding, callback) {\n    // ...\n  }\n});\n</code></pre>\n",
              "type": "misc",
              "displayName": "Simplified Construction"
            },
            {
              "textRaw": "Implementing a Writable Stream",
              "name": "implementing_a_writable_stream",
              "desc": "<p>The <code>stream.Writable</code> class is extended to implement a <a href=\"#stream_class_stream_writable\">Writable</a> stream.</p>\n<p>Custom Writable streams <em>must</em> call the <code>new stream.Writable([options])</code>\nconstructor and implement the <code>writable._write()</code> method. The\n<code>writable._writev()</code> method <em>may</em> also be implemented.</p>\n",
              "methods": [
                {
                  "textRaw": "Constructor: new stream.Writable([options])",
                  "type": "method",
                  "name": "Writable",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} ",
                          "options": [
                            {
                              "textRaw": "`highWaterMark` {Number} Buffer level when [`stream.write()`][stream-write] starts returning `false`. Defaults to `16384` (16kb), or `16` for `objectMode` streams. ",
                              "name": "highWaterMark",
                              "type": "Number",
                              "desc": "Buffer level when [`stream.write()`][stream-write] starts returning `false`. Defaults to `16384` (16kb), or `16` for `objectMode` streams."
                            },
                            {
                              "textRaw": "`decodeStrings` {Boolean} Whether or not to decode strings into Buffers before passing them to [`stream._write()`][stream-_write]. Defaults to `true` ",
                              "name": "decodeStrings",
                              "type": "Boolean",
                              "desc": "Whether or not to decode strings into Buffers before passing them to [`stream._write()`][stream-_write]. Defaults to `true`"
                            },
                            {
                              "textRaw": "`objectMode` {Boolean} Whether or not the [`stream.write(anyObj)`][stream-write] is a valid operation. When set, it becomes possible to write JavaScript values other than string or `Buffer` if supported by the stream implementation. Defaults to `false` ",
                              "name": "objectMode",
                              "type": "Boolean",
                              "desc": "Whether or not the [`stream.write(anyObj)`][stream-write] is a valid operation. When set, it becomes possible to write JavaScript values other than string or `Buffer` if supported by the stream implementation. Defaults to `false`"
                            },
                            {
                              "textRaw": "`write` {Function} Implementation for the [`stream._write()`][stream-_write] method. ",
                              "name": "write",
                              "type": "Function",
                              "desc": "Implementation for the [`stream._write()`][stream-_write] method."
                            },
                            {
                              "textRaw": "`writev` {Function} Implementation for the [`stream._writev()`][stream-_writev] method. ",
                              "name": "writev",
                              "type": "Function",
                              "desc": "Implementation for the [`stream._writev()`][stream-_writev] method."
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>For example:</p>\n<pre><code class=\"lang-js\">const Writable = require(&#39;stream&#39;).Writable;\n\nclass MyWritable extends Writable {\n  constructor(options) {\n    // Calls the stream.Writable() constructor\n    super(options);\n  }\n}\n</code></pre>\n<p>Or, when using pre-ES6 style constructors:</p>\n<pre><code class=\"lang-js\">const Writable = require(&#39;stream&#39;).Writable;\nconst util = require(&#39;util&#39;);\n\nfunction MyWritable(options) {\n  if (!(this instanceof MyWritable))\n    return new MyWritable(options);\n  Writable.call(this, options);\n}\nutil.inherits(MyWritable, Writable);\n</code></pre>\n<p>Or, using the Simplified Constructor approach:</p>\n<pre><code class=\"lang-js\">const Writable = require(&#39;stream&#39;).Writable;\n\nconst myWritable = new Writable({\n  write(chunk, encoding, callback) {\n    // ...\n  },\n  writev(chunks, callback) {\n    // ...\n  }\n});\n</code></pre>\n"
                },
                {
                  "textRaw": "writable.\\_write(chunk, encoding, callback)",
                  "type": "method",
                  "name": "\\_write",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`chunk` {Buffer|String} The chunk to be written. Will **always** be a buffer unless the `decodeStrings` option was set to `false`. ",
                          "name": "chunk",
                          "type": "Buffer|String",
                          "desc": "The chunk to be written. Will **always** be a buffer unless the `decodeStrings` option was set to `false`."
                        },
                        {
                          "textRaw": "`encoding` {String} If the chunk is a string, then `encoding` is the character encoding of that string. If chunk is a `Buffer`, or if the stream is operating in object mode, `encoding` may be ignored. ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "If the chunk is a string, then `encoding` is the character encoding of that string. If chunk is a `Buffer`, or if the stream is operating in object mode, `encoding` may be ignored."
                        },
                        {
                          "textRaw": "`callback` {Function} Call this function (optionally with an error argument) when processing is complete for the supplied chunk. ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "Call this function (optionally with an error argument) when processing is complete for the supplied chunk."
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding"
                        },
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>All Writable stream implementations must provide a\n<a href=\"#stream_writable_write_chunk_encoding_callback_1\"><code>writable._write()</code></a> method to send data to the underlying\nresource.</p>\n<p><em>Note</em>: <a href=\"#stream_class_stream_transform\">Transform</a> streams provide their own implementation of the\n<a href=\"#stream_writable_write_chunk_encoding_callback_1\"><code>writable._write()</code></a>.</p>\n<p><em>Note</em>: <strong>This function MUST NOT be called by application code directly.</strong> It\nshould be implemented by child classes, and called only by the internal Writable\nclass methods only.</p>\n<p>The <code>callback</code> method must be called to signal either that the write completed\nsuccessfully or failed with an error. The first argument passed to the\n<code>callback</code> must be the <code>Error</code> object if the call failed or <code>null</code> if the\nwrite succeeded.</p>\n<p>It is important to note that all calls to <code>writable.write()</code> that occur between\nthe time <code>writable._write()</code> is called and the <code>callback</code> is called will cause\nthe written data to be buffered. Once the <code>callback</code> is invoked, the stream will\nemit a <a href=\"#stream_event_drain\"><code>&#39;drain&#39;</code></a> event. If a stream implementation is capable of processing\nmultiple chunks of data at once, the <code>writable._writev()</code> method should be\nimplemented.</p>\n<p>If the <code>decodeStrings</code> property is set in the constructor options, then\n<code>chunk</code> may be a string rather than a Buffer, and <code>encoding</code> will\nindicate the character encoding of the string. This is to support\nimplementations that have an optimized handling for certain string\ndata encodings. If the <code>decodeStrings</code> property is explicitly set to <code>false</code>,\nthe <code>encoding</code> argument can be safely ignored, and <code>chunk</code> will remain the same\nobject that is passed to <code>.write()</code>.</p>\n<p>The <code>writable._write()</code> method is prefixed with an underscore because it is\ninternal to the class that defines it, and should never be called directly by\nuser programs.</p>\n"
                },
                {
                  "textRaw": "writable.\\_writev(chunks, callback)",
                  "type": "method",
                  "name": "\\_writev",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`chunks` {Array} The chunks to be written. Each chunk has following format: `{ chunk: ..., encoding: ... }`. ",
                          "name": "chunks",
                          "type": "Array",
                          "desc": "The chunks to be written. Each chunk has following format: `{ chunk: ..., encoding: ... }`."
                        },
                        {
                          "textRaw": "`callback` {Function} A callback function (optionally with an error argument) to be invoked when processing is complete for the supplied chunks. ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "A callback function (optionally with an error argument) to be invoked when processing is complete for the supplied chunks."
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "chunks"
                        },
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ],
                  "desc": "<p><em>Note</em>: <strong>This function MUST NOT be called by application code directly.</strong> It\nshould be implemented by child classes, and called only by the internal Writable\nclass methods only.</p>\n<p>The <code>writable._writev()</code> method may be implemented in addition to\n<code>writable._write()</code> in stream implementations that are capable of processing\nmultiple chunks of data at once. If implemented, the method will be called with\nall chunks of data currently buffered in the write queue.</p>\n<p>The <code>writable._writev()</code> method is prefixed with an underscore because it is\ninternal to the class that defines it, and should never be called directly by\nuser programs.</p>\n"
                }
              ],
              "modules": [
                {
                  "textRaw": "Errors While Writing",
                  "name": "errors_while_writing",
                  "desc": "<p>It is recommended that errors occurring during the processing of the\n<code>writable._write()</code> and <code>writable._writev()</code> methods are reported by invoking\nthe callback and passing the error as the first argument. This will cause an\n<code>&#39;error&#39;</code> event to be emitted by the Writable. Throwing an Error from within\n<code>writable._write()</code> can result in expected and inconsistent behavior depending\non how the stream is being used.  Using the callback ensures consistent and\npredictable handling of errors.</p>\n<pre><code class=\"lang-js\">const Writable = require(&#39;stream&#39;).Writable;\n\nconst myWritable = new Writable({\n  write(chunk, encoding, callback) {\n    if (chunk.toString().indexOf(&#39;a&#39;) &gt;= 0) {\n      callback(new Error(&#39;chunk is invalid&#39;));\n    } else {\n      callback();\n    }\n  }\n});\n</code></pre>\n",
                  "type": "module",
                  "displayName": "Errors While Writing"
                },
                {
                  "textRaw": "An Example Writable Stream",
                  "name": "an_example_writable_stream",
                  "desc": "<p>The following illustrates a rather simplistic (and somewhat pointless) custom\nWritable stream implementation. While this specific Writable stream instance\nis not of any real particular usefulness, the example illustrates each of the\nrequired elements of a custom <a href=\"#stream_class_stream_writable\">Writable</a> stream instance:</p>\n<pre><code class=\"lang-js\">const Writable = require(&#39;stream&#39;).Writable;\n\nclass MyWritable extends Writable {\n  constructor(options) {\n    super(options);\n  }\n\n  _write(chunk, encoding, callback) {\n    if (chunk.toString().indexOf(&#39;a&#39;) &gt;= 0) {\n      callback(new Error(&#39;chunk is invalid&#39;));\n    } else {\n      callback();\n    }\n  }\n}\n</code></pre>\n",
                  "type": "module",
                  "displayName": "An Example Writable Stream"
                }
              ],
              "type": "misc",
              "displayName": "Implementing a Writable Stream"
            },
            {
              "textRaw": "Implementing a Readable Stream",
              "name": "implementing_a_readable_stream",
              "desc": "<p>The <code>stream.Readable</code> class is extended to implement a <a href=\"#stream_class_stream_readable\">Readable</a> stream.</p>\n<p>Custom Readable streams <em>must</em> call the <code>new stream.Readable([options])</code>\nconstructor and implement the <code>readable._read()</code> method.</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Readable([options])",
                  "type": "method",
                  "name": "Readable",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} ",
                          "options": [
                            {
                              "textRaw": "`highWaterMark` {Number} The maximum number of bytes to store in the internal buffer before ceasing to read from the underlying resource. Defaults to `16384` (16kb), or `16` for `objectMode` streams ",
                              "name": "highWaterMark",
                              "type": "Number",
                              "desc": "The maximum number of bytes to store in the internal buffer before ceasing to read from the underlying resource. Defaults to `16384` (16kb), or `16` for `objectMode` streams"
                            },
                            {
                              "textRaw": "`encoding` {String} If specified, then buffers will be decoded to strings using the specified encoding. Defaults to `null` ",
                              "name": "encoding",
                              "type": "String",
                              "desc": "If specified, then buffers will be decoded to strings using the specified encoding. Defaults to `null`"
                            },
                            {
                              "textRaw": "`objectMode` {Boolean} Whether this stream should behave as a stream of objects. Meaning that [`stream.read(n)`][stream-read] returns a single value instead of a Buffer of size n. Defaults to `false` ",
                              "name": "objectMode",
                              "type": "Boolean",
                              "desc": "Whether this stream should behave as a stream of objects. Meaning that [`stream.read(n)`][stream-read] returns a single value instead of a Buffer of size n. Defaults to `false`"
                            },
                            {
                              "textRaw": "`read` {Function} Implementation for the [`stream._read()`][stream-_read] method. ",
                              "name": "read",
                              "type": "Function",
                              "desc": "Implementation for the [`stream._read()`][stream-_read] method."
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>For example:</p>\n<pre><code class=\"lang-js\">const Readable = require(&#39;stream&#39;).Readable;\n\nclass MyReadable extends Readable {\n  constructor(options) {\n    // Calls the stream.Readable(options) constructor\n    super(options);\n  }\n}\n</code></pre>\n<p>Or, when using pre-ES6 style constructors:</p>\n<pre><code class=\"lang-js\">const Readable = require(&#39;stream&#39;).Readable;\nconst util = require(&#39;util&#39;);\n\nfunction MyReadable(options) {\n  if (!(this instanceof MyReadable))\n    return new MyReadable(options);\n  Readable.call(this, options);\n}\nutil.inherits(MyReadable, Readable);\n</code></pre>\n<p>Or, using the Simplified Constructor approach:</p>\n<pre><code class=\"lang-js\">const Readable = require(&#39;stream&#39;).Readable;\n\nconst myReadable = new Readable({\n  read(size) {\n    // ...\n  }\n});\n</code></pre>\n"
                },
                {
                  "textRaw": "readable.\\_read(size)",
                  "type": "method",
                  "name": "\\_read",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`size` {Number} Number of bytes to read asynchronously ",
                          "name": "size",
                          "type": "Number",
                          "desc": "Number of bytes to read asynchronously"
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "size"
                        }
                      ]
                    }
                  ],
                  "desc": "<p><em>Note</em>: <strong>This function MUST NOT be called by application code directly.</strong> It\nshould be implemented by child classes, and called only by the internal Readable\nclass methods only.</p>\n<p>All Readable stream implementations must provide an implementation of the\n<code>readable._read()</code> method to fetch data from the underlying resource.</p>\n<p>When <code>readable._read()</code> is called, if data is available from the resource, the\nimplementation should begin pushing that data into the read queue using the\n<a href=\"#stream_readable_push_chunk_encoding\"><code>this.push(dataChunk)</code></a> method. <code>_read()</code> should continue reading\nfrom the resource and pushing data until <code>readable.push()</code> returns <code>false</code>. Only\nwhen <code>_read()</code> is called again after it has stopped should it resume pushing\nadditional data onto the queue.</p>\n<p><em>Note</em>: Once the <code>readable._read()</code> method has been called, it will not be\ncalled again until the <a href=\"#stream_readable_push_chunk_encoding\"><code>readable.push()</code></a> method is called.</p>\n<p>The <code>size</code> argument is advisory. For implementations where a &quot;read&quot; is a\nsingle operation that returns data can use the <code>size</code> argument to determine how\nmuch data to fetch. Other implementations may ignore this argument and simply\nprovide data whenever it becomes available. There is no need to &quot;wait&quot; until\n<code>size</code> bytes are available before calling <a href=\"#stream_readable_push_chunk_encoding\"><code>stream.push(chunk)</code></a>.</p>\n<p>The <code>readable._read()</code> method is prefixed with an underscore because it is\ninternal to the class that defines it, and should never be called directly by\nuser programs.</p>\n"
                },
                {
                  "textRaw": "readable.push(chunk[, encoding])",
                  "type": "method",
                  "name": "push",
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns {Boolean} `true` if additional chunks of data may continued to be pushed; `false` otherwise. ",
                        "name": "return",
                        "type": "Boolean",
                        "desc": "`true` if additional chunks of data may continued to be pushed; `false` otherwise."
                      },
                      "params": [
                        {
                          "textRaw": "`chunk` {Buffer|Null|String} Chunk of data to push into the read queue ",
                          "name": "chunk",
                          "type": "Buffer|Null|String",
                          "desc": "Chunk of data to push into the read queue"
                        },
                        {
                          "textRaw": "`encoding` {String} Encoding of String chunks.  Must be a valid Buffer encoding, such as `'utf8'` or `'ascii'` ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "Encoding of String chunks.  Must be a valid Buffer encoding, such as `'utf8'` or `'ascii'`",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>When <code>chunk</code> is a <code>Buffer</code> or <code>string</code>, the <code>chunk</code> of data will be added to the\ninternal queue for users of the stream to consume. Passing <code>chunk</code> as <code>null</code>\nsignals the end of the stream (EOF), after which no more data can be written.</p>\n<p>When the Readable is operating in paused mode, the data added with\n<code>readable.push()</code> can be read out by calling the\n<a href=\"#stream_readable_read_size\"><code>readable.read()</code></a> method when the <a href=\"#stream_event_readable\"><code>&#39;readable&#39;</code></a> event is\nemitted.</p>\n<p>When the Readable is operating in flowing mode, the data added with\n<code>readable.push()</code> will be delivered by emitting a <code>&#39;data&#39;</code> event.</p>\n<p>The <code>readable.push()</code> method is designed to be as flexible as possible. For\nexample, when wrapping a lower-level source that provides some form of\npause/resume mechanism, and a data callback, the low-level source can be wrapped\nby the custom Readable instance as illustrated in the following example:</p>\n<pre><code class=\"lang-js\">// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nclass SourceWrapper extends Readable {\n  constructor(options) {\n    super(options);\n\n    this._source = getLowlevelSourceObject();\n\n    // Every time there&#39;s data, push it into the internal buffer.\n    this._source.ondata = (chunk) =&gt; {\n      // if push() returns false, then stop reading from source\n      if (!this.push(chunk))\n        this._source.readStop();\n    };\n\n    // When the source ends, push the EOF-signaling `null` chunk\n    this._source.onend = () =&gt; {\n      this.push(null);\n    };\n  }\n  // _read will be called when the stream wants to pull more data in\n  // the advisory size argument is ignored in this case.\n  _read(size) {\n    this._source.readStart();\n  }\n}\n</code></pre>\n<p><em>Note</em>: The <code>readable.push()</code> method is intended be called only by Readable\nImplementers, and only from within the <code>readable._read()</code> method.</p>\n"
                }
              ],
              "modules": [
                {
                  "textRaw": "Errors While Reading",
                  "name": "errors_while_reading",
                  "desc": "<p>It is recommended that errors occurring during the processing of the\n<code>readable._read()</code> method are emitted using the <code>&#39;error&#39;</code> event rather than\nbeing thrown. Throwing an Error from within <code>readable._read()</code> can result in\nunexpected and inconsistent behavior depending on whether the stream is\noperating in flowing or paused mode. Using the <code>&#39;error&#39;</code> event ensures\nconsistent and predictable handling of errors.</p>\n<pre><code class=\"lang-js\">const Readable = require(&#39;stream&#39;).Readable;\n\nconst myReadable = new Readable({\n  read(size) {\n    if (checkSomeErrorCondition()) {\n      process.nextTick(() =&gt; this.emit(&#39;error&#39;, err));\n      return;\n    }\n    // do some work\n  }\n});\n</code></pre>\n",
                  "type": "module",
                  "displayName": "Errors While Reading"
                }
              ],
              "examples": [
                {
                  "textRaw": "An Example Counting Stream",
                  "name": "An Example Counting Stream",
                  "type": "example",
                  "desc": "<p>The following is a basic example of a Readable stream that emits the numerals\nfrom 1 to 1,000,000 in ascending order, and then ends.</p>\n<pre><code class=\"lang-js\">const Readable = require(&#39;stream&#39;).Readable;\n\nclass Counter extends Readable {\n  constructor(opt) {\n    super(opt);\n    this._max = 1000000;\n    this._index = 1;\n  }\n\n  _read() {\n    var i = this._index++;\n    if (i &gt; this._max)\n      this.push(null);\n    else {\n      var str = &#39;&#39; + i;\n      var buf = Buffer.from(str, &#39;ascii&#39;);\n      this.push(buf);\n    }\n  }\n}\n</code></pre>\n"
                }
              ],
              "type": "misc",
              "displayName": "Implementing a Readable Stream"
            },
            {
              "textRaw": "Implementing a Duplex Stream",
              "name": "implementing_a_duplex_stream",
              "desc": "<p>A <a href=\"#stream_class_stream_duplex\">Duplex</a> stream is one that implements both <a href=\"#stream_class_stream_readable\">Readable</a> and <a href=\"#stream_class_stream_writable\">Writable</a>,\nsuch as a TCP socket connection.</p>\n<p>Because JavaScript does not have support for multiple inheritance, the\n<code>stream.Duplex</code> class is extended to implement a <a href=\"#stream_class_stream_duplex\">Duplex</a> stream (as opposed\nto extending the <code>stream.Readable</code> <em>and</em> <code>stream.Writable</code> classes).</p>\n<p><em>Note</em>: The <code>stream.Duplex</code> class prototypically inherits from <code>stream.Readable</code>\nand parasitically from <code>stream.Writable</code>, but <code>instanceof</code> will work properly\nfor both base classes due to overriding <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance\"><code>Symbol.hasInstance</code></a>\non <code>stream.Writable</code>.</p>\n<p>Custom Duplex streams <em>must</em> call the <code>new stream.Duplex([options])</code>\nconstructor and implement <em>both</em> the <code>readable._read()</code> and\n<code>writable._write()</code> methods.</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Duplex(options)",
                  "type": "method",
                  "name": "Duplex",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} Passed to both Writable and Readable constructors. Also has the following fields: ",
                          "options": [
                            {
                              "textRaw": "`allowHalfOpen` {Boolean} Defaults to `true`. If set to `false`, then the stream will automatically end the readable side when the writable side ends and vice versa. ",
                              "name": "allowHalfOpen",
                              "type": "Boolean",
                              "desc": "Defaults to `true`. If set to `false`, then the stream will automatically end the readable side when the writable side ends and vice versa."
                            },
                            {
                              "textRaw": "`readableObjectMode` {Boolean} Defaults to `false`. Sets `objectMode` for readable side of the stream. Has no effect if `objectMode` is `true`. ",
                              "name": "readableObjectMode",
                              "type": "Boolean",
                              "desc": "Defaults to `false`. Sets `objectMode` for readable side of the stream. Has no effect if `objectMode` is `true`."
                            },
                            {
                              "textRaw": "`writableObjectMode` {Boolean} Defaults to `false`. Sets `objectMode` for writable side of the stream. Has no effect if `objectMode` is `true`. ",
                              "name": "writableObjectMode",
                              "type": "Boolean",
                              "desc": "Defaults to `false`. Sets `objectMode` for writable side of the stream. Has no effect if `objectMode` is `true`."
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "Passed to both Writable and Readable constructors. Also has the following fields:"
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>For example:</p>\n<pre><code class=\"lang-js\">const Duplex = require(&#39;stream&#39;).Duplex;\n\nclass MyDuplex extends Duplex {\n  constructor(options) {\n    super(options);\n  }\n}\n</code></pre>\n<p>Or, when using pre-ES6 style constructors:</p>\n<pre><code class=\"lang-js\">const Duplex = require(&#39;stream&#39;).Duplex;\nconst util = require(&#39;util&#39;);\n\nfunction MyDuplex(options) {\n  if (!(this instanceof MyDuplex))\n    return new MyDuplex(options);\n  Duplex.call(this, options);\n}\nutil.inherits(MyDuplex, Duplex);\n</code></pre>\n<p>Or, using the Simplified Constructor approach:</p>\n<pre><code class=\"lang-js\">const Duplex = require(&#39;stream&#39;).Duplex;\n\nconst myDuplex = new Duplex({\n  read(size) {\n    // ...\n  },\n  write(chunk, encoding, callback) {\n    // ...\n  }\n});\n</code></pre>\n"
                }
              ],
              "modules": [
                {
                  "textRaw": "An Example Duplex Stream",
                  "name": "an_example_duplex_stream",
                  "desc": "<p>The following illustrates a simple example of a Duplex stream that wraps a\nhypothetical lower-level source object to which data can be written, and\nfrom which data can be read, albeit using an API that is not compatible with\nNode.js streams.\nThe following illustrates a simple example of a Duplex stream that buffers\nincoming written data via the <a href=\"#stream_class_stream_writable\">Writable</a> interface that is read back out\nvia the <a href=\"#stream_class_stream_readable\">Readable</a> interface.</p>\n<pre><code class=\"lang-js\">const Duplex = require(&#39;stream&#39;).Duplex;\nconst kSource = Symbol(&#39;source&#39;);\n\nclass MyDuplex extends Duplex {\n  constructor(source, options) {\n    super(options);\n    this[kSource] = source;\n  }\n\n  _write(chunk, encoding, callback) {\n    // The underlying source only deals with strings\n    if (Buffer.isBuffer(chunk))\n      chunk = chunk.toString();\n    this[kSource].writeSomeData(chunk);\n    callback();\n  }\n\n  _read(size) {\n    this[kSource].fetchSomeData(size, (data, encoding) =&gt; {\n      this.push(Buffer.from(data, encoding));\n    });\n  }\n}\n</code></pre>\n<p>The most important aspect of a Duplex stream is that the Readable and Writable\nsides operate independently of one another despite co-existing within a single\nobject instance.</p>\n",
                  "type": "module",
                  "displayName": "An Example Duplex Stream"
                },
                {
                  "textRaw": "Object Mode Duplex Streams",
                  "name": "object_mode_duplex_streams",
                  "desc": "<p>For Duplex streams, <code>objectMode</code> can be set exclusively for either the Readable\nor Writable side using the <code>readableObjectMode</code> and <code>writableObjectMode</code> options\nrespectively.</p>\n<p>In the following example, for instance, a new Transform stream (which is a\ntype of <a href=\"#stream_class_stream_duplex\">Duplex</a> stream) is created that has an object mode Writable side\nthat accepts JavaScript numbers that are converted to hexadecimal strings on\nthe Readable side.</p>\n<pre><code class=\"lang-js\">const Transform = require(&#39;stream&#39;).Transform;\n\n// All Transform streams are also Duplex Streams\nconst myTransform = new Transform({\n  writableObjectMode: true,\n\n  transform(chunk, encoding, callback) {\n    // Coerce the chunk to a number if necessary\n    chunk |= 0;\n\n    // Transform the chunk into something else.\n    const data = chunk.toString(16);\n\n    // Push the data onto the readable queue.\n    callback(null, &#39;0&#39;.repeat(data.length % 2) + data);\n  }\n});\n\nmyTransform.setEncoding(&#39;ascii&#39;);\nmyTransform.on(&#39;data&#39;, (chunk) =&gt; console.log(chunk));\n\nmyTransform.write(1);\n// Prints: 01\nmyTransform.write(10);\n// Prints: 0a\nmyTransform.write(100);\n// Prints: 64\n</code></pre>\n",
                  "type": "module",
                  "displayName": "Object Mode Duplex Streams"
                }
              ],
              "type": "misc",
              "displayName": "Implementing a Duplex Stream"
            },
            {
              "textRaw": "Implementing a Transform Stream",
              "name": "implementing_a_transform_stream",
              "desc": "<p>A <a href=\"#stream_class_stream_transform\">Transform</a> stream is a <a href=\"#stream_class_stream_duplex\">Duplex</a> stream where the output is computed\nin some way from the input. Examples include <a href=\"zlib.html\">zlib</a> streams or <a href=\"crypto.html\">crypto</a>\nstreams that compress, encrypt, or decrypt data.</p>\n<p><em>Note</em>: There is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time. For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended. A <code>zlib</code> stream will produce output\nthat is either much smaller or much larger than its input.</p>\n<p>The <code>stream.Transform</code> class is extended to implement a <a href=\"#stream_class_stream_transform\">Transform</a> stream.</p>\n<p>The <code>stream.Transform</code> class prototypically inherits from <code>stream.Duplex</code> and\nimplements its own versions of the <code>writable._write()</code> and <code>readable._read()</code>\nmethods. Custom Transform implementations <em>must</em> implement the\n<a href=\"#stream_transform_transform_chunk_encoding_callback\"><code>transform._transform()</code></a> method and <em>may</em> also implement\nthe <a href=\"#stream_transform_flush_callback\"><code>transform._flush()</code></a> method.</p>\n<p><em>Note</em>: Care must be taken when using Transform streams in that data written\nto the stream can cause the Writable side of the stream to become paused if\nthe output on the Readable side is not consumed.</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Transform([options])",
                  "type": "method",
                  "name": "Transform",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} Passed to both Writable and Readable constructors. Also has the following fields: ",
                          "options": [
                            {
                              "textRaw": "`transform` {Function} Implementation for the [`stream._transform()`][stream-_transform] method. ",
                              "name": "transform",
                              "type": "Function",
                              "desc": "Implementation for the [`stream._transform()`][stream-_transform] method."
                            },
                            {
                              "textRaw": "`flush` {Function} Implementation for the [`stream._flush()`][stream-_flush] method. ",
                              "name": "flush",
                              "type": "Function",
                              "desc": "Implementation for the [`stream._flush()`][stream-_flush] method."
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "Passed to both Writable and Readable constructors. Also has the following fields:",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>For example:</p>\n<pre><code class=\"lang-js\">const Transform = require(&#39;stream&#39;).Transform;\n\nclass MyTransform extends Transform {\n  constructor(options) {\n    super(options);\n  }\n}\n</code></pre>\n<p>Or, when using pre-ES6 style constructors:</p>\n<pre><code class=\"lang-js\">const Transform = require(&#39;stream&#39;).Transform;\nconst util = require(&#39;util&#39;);\n\nfunction MyTransform(options) {\n  if (!(this instanceof MyTransform))\n    return new MyTransform(options);\n  Transform.call(this, options);\n}\nutil.inherits(MyTransform, Transform);\n</code></pre>\n<p>Or, using the Simplified Constructor approach:</p>\n<pre><code class=\"lang-js\">const Transform = require(&#39;stream&#39;).Transform;\n\nconst myTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // ...\n  }\n});\n</code></pre>\n"
                },
                {
                  "textRaw": "transform.\\_flush(callback)",
                  "type": "method",
                  "name": "\\_flush",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`callback` {Function} A callback function (optionally with an error argument and data) to be called when remaining data has been flushed. ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "A callback function (optionally with an error argument and data) to be called when remaining data has been flushed."
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ],
                  "desc": "<p><em>Note</em>: <strong>This function MUST NOT be called by application code directly.</strong> It\nshould be implemented by child classes, and called only by the internal Readable\nclass methods only.</p>\n<p>In some cases, a transform operation may need to emit an additional bit of\ndata at the end of the stream. For example, a <code>zlib</code> compression stream will\nstore an amount of internal state used to optimally compress the output. When\nthe stream ends, however, that additional data needs to be flushed so that the\ncompressed data will be complete.</p>\n<p>Custom <a href=\"#stream_class_stream_transform\">Transform</a> implementations <em>may</em> implement the <code>transform._flush()</code>\nmethod. This will be called when there is no more written data to be consumed,\nbut before the <a href=\"#stream_event_end\"><code>&#39;end&#39;</code></a> event is emitted signaling the end of the\n<a href=\"#stream_class_stream_readable\">Readable</a> stream.</p>\n<p>Within the <code>transform._flush()</code> implementation, the <code>readable.push()</code> method\nmay be called zero or more times, as appropriate. The <code>callback</code> function must\nbe called when the flush operation is complete.</p>\n<p>The <code>transform._flush()</code> method is prefixed with an underscore because it is\ninternal to the class that defines it, and should never be called directly by\nuser programs.</p>\n"
                },
                {
                  "textRaw": "transform.\\_transform(chunk, encoding, callback)",
                  "type": "method",
                  "name": "\\_transform",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`chunk` {Buffer|String} The chunk to be transformed. Will **always** be a buffer unless the `decodeStrings` option was set to `false`. ",
                          "name": "chunk",
                          "type": "Buffer|String",
                          "desc": "The chunk to be transformed. Will **always** be a buffer unless the `decodeStrings` option was set to `false`."
                        },
                        {
                          "textRaw": "`encoding` {String} If the chunk is a string, then this is the encoding type. If chunk is a buffer, then this is the special value - 'buffer', ignore it in this case. ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "If the chunk is a string, then this is the encoding type. If chunk is a buffer, then this is the special value - 'buffer', ignore it in this case."
                        },
                        {
                          "textRaw": "`callback` {Function} A callback function (optionally with an error argument and data) to be called after the supplied `chunk` has been processed. ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "A callback function (optionally with an error argument and data) to be called after the supplied `chunk` has been processed."
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding"
                        },
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ],
                  "desc": "<p><em>Note</em>: <strong>This function MUST NOT be called by application code directly.</strong> It\nshould be implemented by child classes, and called only by the internal Readable\nclass methods only.</p>\n<p>All Transform stream implementations must provide a <code>_transform()</code>\nmethod to accept input and produce output. The <code>transform._transform()</code>\nimplementation handles the bytes being written, computes an output, then passes\nthat output off to the readable portion using the <code>readable.push()</code> method.</p>\n<p>The <code>transform.push()</code> method may be called zero or more times to generate\noutput from a single input chunk, depending on how much is to be output\nas a result of the chunk.</p>\n<p>It is possible that no output is generated from any given chunk of input data.</p>\n<p>The <code>callback</code> function must be called only when the current chunk is completely\nconsumed. The first argument passed to the <code>callback</code> must be an <code>Error</code> object\nif an error occurred while processing the input or <code>null</code> otherwise. If a second\nargument is passed to the <code>callback</code>, it will be forwarded on to the\n<code>readable.push()</code> method. In other words the following are equivalent:</p>\n<pre><code class=\"lang-js\">transform.prototype._transform = function (data, encoding, callback) {\n  this.push(data);\n  callback();\n};\n\ntransform.prototype._transform = function (data, encoding, callback) {\n  callback(null, data);\n};\n</code></pre>\n<p>The <code>transform._transform()</code> method is prefixed with an underscore because it\nis internal to the class that defines it, and should never be called directly by\nuser programs.</p>\n"
                }
              ],
              "modules": [
                {
                  "textRaw": "Events: 'finish' and 'end'",
                  "name": "events:_'finish'_and_'end'",
                  "desc": "<p>The <a href=\"#stream_event_finish\"><code>&#39;finish&#39;</code></a> and <a href=\"#stream_event_end\"><code>&#39;end&#39;</code></a> events are from the <code>stream.Writable</code>\nand <code>stream.Readable</code> classes, respectively. The <code>&#39;finish&#39;</code> event is emitted\nafter <a href=\"#stream_writable_end_chunk_encoding_callback\"><code>stream.end()</code></a> is called and all chunks have been processed\nby <a href=\"#stream_transform_transform_chunk_encoding_callback\"><code>stream._transform()</code></a>. The <code>&#39;end&#39;</code> event is emitted\nafter all data has been output, which occurs after the callback in\n<a href=\"#stream_transform_flush_callback\"><code>transform._flush()</code></a> has been called.</p>\n",
                  "type": "module",
                  "displayName": "Events: 'finish' and 'end'"
                }
              ],
              "classes": [
                {
                  "textRaw": "Class: stream.PassThrough",
                  "type": "class",
                  "name": "stream.PassThrough",
                  "desc": "<p>The <code>stream.PassThrough</code> class is a trivial implementation of a <a href=\"#stream_class_stream_transform\">Transform</a>\nstream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where\n<code>stream.PassThrough</code> is useful as a building block for novel sorts of streams.</p>\n"
                }
              ],
              "type": "misc",
              "displayName": "Implementing a Transform Stream"
            }
          ]
        },
        {
          "textRaw": "Additional Notes",
          "name": "Additional Notes",
          "type": "misc",
          "miscs": [
            {
              "textRaw": "Compatibility with Older Node.js Versions",
              "name": "Compatibility with Older Node.js Versions",
              "type": "misc",
              "desc": "<p>In versions of Node.js prior to v0.10, the Readable stream interface was\nsimpler, but also less powerful and less useful.</p>\n<ul>\n<li>Rather than waiting for calls the <a href=\"#stream_readable_read_size\"><code>stream.read()</code></a> method,\n<a href=\"#stream_event_data\"><code>&#39;data&#39;</code></a> events would begin emitting immediately. Applications that\nwould need to perform some amount of work to decide how to handle data\nwere required to store read data into buffers so the data would not be lost.</li>\n<li>The <a href=\"#stream_readable_pause\"><code>stream.pause()</code></a> method was advisory, rather than\nguaranteed. This meant that it was still necessary to be prepared to receive\n<a href=\"#stream_event_data\"><code>&#39;data&#39;</code></a> events <em>even when the stream was in a paused state</em>.</li>\n</ul>\n<p>In Node.js v0.10, the <a href=\"#stream_class_stream_readable\">Readable</a> class was added. For backwards compatibility\nwith older Node.js programs, Readable streams switch into &quot;flowing mode&quot; when a\n<a href=\"#stream_event_data\"><code>&#39;data&#39;</code></a> event handler is added, or when the\n<a href=\"#stream_readable_resume\"><code>stream.resume()</code></a> method is called. The effect is that, even\nwhen not using the new <a href=\"#stream_readable_read_size\"><code>stream.read()</code></a> method and\n<a href=\"#stream_event_readable\"><code>&#39;readable&#39;</code></a> event, it is no longer necessary to worry about losing\n<a href=\"#stream_event_data\"><code>&#39;data&#39;</code></a> chunks.</p>\n<p>While most applications will continue to function normally, this introduces an\nedge case in the following conditions:</p>\n<ul>\n<li>No <a href=\"#stream_event_data\"><code>&#39;data&#39;</code></a> event listener is added.</li>\n<li>The <a href=\"#stream_readable_resume\"><code>stream.resume()</code></a> method is never called.</li>\n<li>The stream is not piped to any writable destination.</li>\n</ul>\n<p>For example, consider the following code:</p>\n<pre><code class=\"lang-js\">// WARNING!  BROKEN!\nnet.createServer((socket) =&gt; {\n\n  // we add an &#39;end&#39; method, but never consume the data\n  socket.on(&#39;end&#39;, () =&gt; {\n    // It will never get here.\n    socket.end(&#39;The message was received but was not processed.\\n&#39;);\n  });\n\n}).listen(1337);\n</code></pre>\n<p>In versions of Node.js prior to v0.10, the incoming message data would be\nsimply discarded. However, in Node.js v0.10 and beyond, the socket remains\npaused forever.</p>\n<p>The workaround in this situation is to call the\n<a href=\"#stream_readable_resume\"><code>stream.resume()</code></a> method to begin the flow of data:</p>\n<pre><code class=\"lang-js\">// Workaround\nnet.createServer((socket) =&gt; {\n\n  socket.on(&#39;end&#39;, () =&gt; {\n    socket.end(&#39;The message was received but was not processed.\\n&#39;);\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);\n</code></pre>\n<p>In addition to new Readable streams switching into flowing mode,\npre-v0.10 style streams can be wrapped in a Readable class using the\n<a href=\"#stream_readable_wrap_stream\"><code>readable.wrap()</code></a> method.</p>\n"
            },
            {
              "textRaw": "`readable.read(0)`",
              "name": "`readable.read(0)`",
              "desc": "<p>There are some cases where it is necessary to trigger a refresh of the\nunderlying readable stream mechanisms, without actually consuming any\ndata. In such cases, it is possible to call <code>readable.read(0)</code>, which will\nalways return <code>null</code>.</p>\n<p>If the internal read buffer is below the <code>highWaterMark</code>, and the\nstream is not currently reading, then calling <code>stream.read(0)</code> will trigger\na low-level <a href=\"#stream_readable_read_size_1\"><code>stream._read()</code></a> call.</p>\n<p>While most applications will almost never need to do this, there are\nsituations within Node.js where this is done, particularly in the\nReadable stream class internals.</p>\n",
              "type": "misc",
              "displayName": "`readable.read(0)`"
            },
            {
              "textRaw": "`readable.push('')`",
              "name": "`readable.push('')`",
              "desc": "<p>Use of <code>readable.push(&#39;&#39;)</code> is not recommended.</p>\n<p>Pushing a zero-byte string or <code>Buffer</code> to a stream that is not in object mode\nhas an interesting side effect. Because it <em>is</em> a call to\n<a href=\"#stream_readable_push_chunk_encoding\"><code>readable.push()</code></a>, the call will end the reading process.\nHowever, because the argument is an empty string, no data is added to the\nreadable buffer so there is nothing for a user to consume.</p>\n",
              "type": "misc",
              "displayName": "`readable.push('')`"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Stream"
    }
  ]
}
