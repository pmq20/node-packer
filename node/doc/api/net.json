{
  "source": "doc/api/net.md",
  "modules": [
    {
      "textRaw": "Net",
      "name": "net",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>The <code>net</code> module provides an asynchronous network API for creating stream-based\nTCP or <a href=\"#net_ipc_support\">IPC</a> servers (<a href=\"#net_net_createserver_options_connectionlistener\"><code>net.createServer()</code></a>) and clients\n(<a href=\"#net_net_createconnection\"><code>net.createConnection()</code></a>).</p>\n<p>It can be accessed using:</p>\n<pre><code class=\"lang-js\">const net = require(&#39;net&#39;);\n</code></pre>\n",
      "modules": [
        {
          "textRaw": "IPC Support",
          "name": "ipc_support",
          "desc": "<p>The <code>net</code> module supports IPC with named pipes on Windows, and UNIX domain\nsockets on other operating systems.</p>\n",
          "modules": [
            {
              "textRaw": "Identifying paths for IPC connections",
              "name": "identifying_paths_for_ipc_connections",
              "desc": "<p><a href=\"#net_net_connect\"><code>net.connect()</code></a>, <a href=\"#net_net_createconnection\"><code>net.createConnection()</code></a>, <a href=\"#net_server_listen\"><code>server.listen()</code></a> and\n<a href=\"#net_socket_connect\"><code>socket.connect()</code></a> take a <code>path</code> parameter to identify IPC endpoints.</p>\n<p>On UNIX, the local domain is also known as the UNIX domain. The path is a\nfilesystem path name. It gets truncated to <code>sizeof(sockaddr_un.sun_path) - 1</code>,\nwhich varies on different operating system between 91 and 107 bytes.\nThe typical values are 107 on Linux and 103 on macOS. The path is\nsubject to the same naming conventions and permissions checks as would be done\non file creation. It will be visible in the filesystem, and will <em>persist until\nunlinked</em>.</p>\n<p>On Windows, the local domain is implemented using a named pipe. The path <em>must</em>\nrefer to an entry in <code>\\\\?\\pipe\\</code> or <code>\\\\.\\pipe\\</code>. Any characters are permitted,\nbut the latter may do some processing of pipe names, such as resolving <code>..</code>\nsequences. Despite appearances, the pipe name space is flat. Pipes will <em>not\npersist</em>, they are removed when the last reference to them is closed. Do not\nforget JavaScript string escaping requires paths to be specified with\ndouble-backslashes, such as:</p>\n<pre><code class=\"lang-js\">net.createServer().listen(\n  path.join(&#39;\\\\\\\\?\\\\pipe&#39;, process.cwd(), &#39;myctl&#39;));\n</code></pre>\n",
              "type": "module",
              "displayName": "Identifying paths for IPC connections"
            }
          ],
          "type": "module",
          "displayName": "IPC Support"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: net.Server",
          "type": "class",
          "name": "net.Server",
          "meta": {
            "added": [
              "v0.1.90"
            ],
            "changes": []
          },
          "desc": "<p>This class is used to create a TCP or <a href=\"#net_ipc_support\">IPC</a> server.</p>\n"
        },
        {
          "textRaw": "Class: net.Socket",
          "type": "class",
          "name": "net.Socket",
          "meta": {
            "added": [
              "v0.3.4"
            ],
            "changes": []
          },
          "desc": "<p>This class is an abstraction of a TCP socket or a streaming <a href=\"#net_ipc_support\">IPC</a> endpoint\n(uses named pipes on Windows, and UNIX domain sockets otherwise). A\n<code>net.Socket</code> is also a <a href=\"stream.html#stream_class_stream_duplex\">duplex stream</a>, so it can be both readable and\nwritable, and it is also a <a href=\"events.html#events_class_eventemitter\"><code>EventEmitter</code></a>.</p>\n<p>A <code>net.Socket</code> can be created by the user and used directly to interact with\na server. For example, it is returned by <a href=\"#net_net_createconnection\"><code>net.createConnection()</code></a>,\nso the user can use it to talk to the server.</p>\n<p>It can also be created by Node.js and passed to the user when a connection\nis received. For example, it is passed to the listeners of a\n<a href=\"#net_event_connection\"><code>&#39;connection&#39;</code></a> event emitted on a <a href=\"#net_class_net_server\"><code>net.Server</code></a>, so the user can use\nit to interact with the client.</p>\n",
          "methods": [
            {
              "textRaw": "new net.Socket([options])",
              "type": "method",
              "name": "Socket",
              "meta": {
                "added": [
                  "v0.3.4"
                ],
                "changes": []
              },
              "desc": "<p>Creates a new socket object.</p>\n<ul>\n<li><code>options</code> {Object} Available options are:<ul>\n<li><code>fd</code>: {number} If specified, wrap around an existing socket with\nthe given file descriptor, otherwise a new socket will be created.</li>\n<li><code>allowHalfOpen</code> {boolean} Indicates whether half-opened TCP connections\nare allowed. See <a href=\"#net_net_createserver_options_connectionlistener\"><code>net.createServer()</code></a> and the <a href=\"#net_event_end\"><code>&#39;end&#39;</code></a> event\nfor details. Defaults to <code>false</code>.</li>\n<li><code>readable</code> {boolean} Allow reads on the socket when an <code>fd</code> is passed,\notherwise ignored. Defaults to <code>false</code>.</li>\n<li><code>writable</code> {boolean} Allow writes on the socket when an <code>fd</code> is passed,\notherwise ignored. Defaults to <code>false</code>.</li>\n</ul>\n</li>\n<li>Returns: {net.Socket}</li>\n</ul>\n<p>The newly created socket can be either a TCP socket or a streaming <a href=\"#net_ipc_support\">IPC</a>\nendpoint, depending on what it <a href=\"#net_socket_connect\"><code>connect()</code></a> to.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.address()",
              "type": "method",
              "name": "address",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Returns the bound address, the address family name and port of the\nsocket as reported by the operating system. Returns an object with\nthree properties, e.g.\n<code>{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code></p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.connect()",
              "type": "method",
              "name": "connect",
              "desc": "<p>Initiate a connection on a given socket.</p>\n<p>Possible signatures:</p>\n<ul>\n<li><a href=\"#net_socket_connect_options_connectlistener\">socket.connect(options[, connectListener])</a></li>\n<li><a href=\"#net_socket_connect_path_connectlistener\">socket.connect(path[, connectListener])</a>\nfor <a href=\"#net_ipc_support\">IPC</a> connections.</li>\n<li><a href=\"#net_socket_connect_port_host_connectlistener\">socket.connect(port[, host][, connectListener])</a>\nfor TCP connections.</li>\n<li>Returns: {net.Socket} The socket itself.</li>\n</ul>\n<p>This function is asynchronous. When the connection is established, the\n<a href=\"#net_event_connect\"><code>&#39;connect&#39;</code></a> event will be emitted. If there is a problem connecting,\ninstead of a <a href=\"#net_event_connect\"><code>&#39;connect&#39;</code></a> event, an <a href=\"#net_event_error_1\"><code>&#39;error&#39;</code></a> event will be emitted with\nthe error passed to the <a href=\"#net_event_error_1\"><code>&#39;error&#39;</code></a> listener.\nThe last parameter <code>connectListener</code>, if supplied, will be added as a listener\nfor the <a href=\"#net_event_connect\"><code>&#39;connect&#39;</code></a> event <strong>once</strong>.</p>\n",
              "methods": [
                {
                  "textRaw": "socket.connect(options[, connectListener])",
                  "type": "method",
                  "name": "connect",
                  "meta": {
                    "added": [
                      "v0.1.90"
                    ],
                    "changes": [
                      {
                        "version": "v6.0.0",
                        "pr-url": "https://github.com/nodejs/node/pull/6021",
                        "description": "The `hints` option defaults to `0` in all cases now. Previously, in the absence of the `family` option it would default to `dns.ADDRCONFIG | dns.V4MAPPED`."
                      },
                      {
                        "version": "v5.11.0",
                        "pr-url": "https://github.com/nodejs/node/pull/6000",
                        "description": "The `hints` option is supported now."
                      }
                    ]
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {net.Socket} The socket itself. ",
                        "name": "return",
                        "type": "net.Socket",
                        "desc": "The socket itself."
                      },
                      "params": [
                        {
                          "textRaw": "`options` {Object} ",
                          "name": "options",
                          "type": "Object"
                        },
                        {
                          "textRaw": "`connectListener` {Function} Common parameter of [`socket.connect()`][] methods. Will be added as a listener for the [`'connect'`][] event once. ",
                          "name": "connectListener",
                          "type": "Function",
                          "desc": "Common parameter of [`socket.connect()`][] methods. Will be added as a listener for the [`'connect'`][] event once.",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options"
                        },
                        {
                          "name": "connectListener",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Initiate a connection on a given socket. Normally this method is not needed,\nthe socket should be created and opened with <a href=\"#net_net_createconnection\"><code>net.createConnection()</code></a>. Use\nthis only when implementing a custom Socket.</p>\n<p>For TCP connections, available <code>options</code> are:</p>\n<ul>\n<li><code>port</code> {number} Required. Port the socket should connect to.</li>\n<li><code>host</code> {string} Host the socket should connect to. Defaults to <code>&#39;localhost&#39;</code>.</li>\n<li><code>localAddress</code> {string} Local address the socket should connect from.</li>\n<li><code>localPort</code> {number} Local port the socket should connect from.</li>\n<li><code>family</code> {number}: Version of IP stack, can be either 4 or 6. Defaults to 4.</li>\n<li><code>hints</code> {number} Optional <a href=\"dns.html#dns_supported_getaddrinfo_flags\"><code>dns.lookup()</code> hints</a>.</li>\n<li><code>lookup</code> {Function} Custom lookup function. Defaults to <a href=\"dns.html#dns_dns_lookup_hostname_options_callback\"><code>dns.lookup()</code></a>.</li>\n</ul>\n<p>For <a href=\"#net_ipc_support\">IPC</a> connections, available <code>options</code> are:</p>\n<ul>\n<li><code>path</code> {string} Required. Path the client should connect to.\nSee <a href=\"#net_identifying_paths_for_ipc_connections\">Identifying paths for IPC connections</a>.</li>\n</ul>\n<p>Returns <code>socket</code>.</p>\n"
                },
                {
                  "textRaw": "socket.connect(path[, connectListener])",
                  "type": "method",
                  "name": "connect",
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {net.Socket} The socket itself. ",
                        "name": "return",
                        "type": "net.Socket",
                        "desc": "The socket itself."
                      },
                      "params": [
                        {
                          "textRaw": "`path` {string} Path the client should connect to. See [Identifying paths for IPC connections][]. ",
                          "name": "path",
                          "type": "string",
                          "desc": "Path the client should connect to. See [Identifying paths for IPC connections][]."
                        },
                        {
                          "textRaw": "`connectListener` {Function} Common parameter of [`socket.connect()`][] methods. Will be added as a listener for the [`'connect'`][] event once. ",
                          "name": "connectListener",
                          "type": "Function",
                          "desc": "Common parameter of [`socket.connect()`][] methods. Will be added as a listener for the [`'connect'`][] event once.",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "path"
                        },
                        {
                          "name": "connectListener",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Initiate an <a href=\"#net_ipc_support\">IPC</a> connection on the given socket.</p>\n<p>Alias to\n<a href=\"#net_socket_connect_options_connectlistener\"><code>socket.connect(options[, connectListener])</code></a>\ncalled with <code>{ path: path }</code> as <code>options</code>.</p>\n<p>Returns <code>socket</code>.</p>\n"
                },
                {
                  "textRaw": "socket.connect(port[, host][, connectListener])",
                  "type": "method",
                  "name": "connect",
                  "meta": {
                    "added": [
                      "v0.1.90"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {net.Socket} The socket itself. ",
                        "name": "return",
                        "type": "net.Socket",
                        "desc": "The socket itself."
                      },
                      "params": [
                        {
                          "textRaw": "`port` {number} Port the client should connect to. ",
                          "name": "port",
                          "type": "number",
                          "desc": "Port the client should connect to."
                        },
                        {
                          "textRaw": "`host` {string} Host the client should connect to. ",
                          "name": "host",
                          "type": "string",
                          "desc": "Host the client should connect to.",
                          "optional": true
                        },
                        {
                          "textRaw": "`connectListener` {Function} Common parameter of [`socket.connect()`][] methods. Will be added as a listener for the [`'connect'`][] event once. ",
                          "name": "connectListener",
                          "type": "Function",
                          "desc": "Common parameter of [`socket.connect()`][] methods. Will be added as a listener for the [`'connect'`][] event once.",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "port"
                        },
                        {
                          "name": "host",
                          "optional": true
                        },
                        {
                          "name": "connectListener",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Initiate a TCP connection on the given socket.</p>\n<p>Alias to\n<a href=\"#net_socket_connect_options_connectlistener\"><code>socket.connect(options[, connectListener])</code></a>\ncalled with <code>{port: port, host: host}</code> as <code>options</code>.</p>\n<p>Returns <code>socket</code>.</p>\n"
                }
              ],
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.destroy([exception])",
              "type": "method",
              "name": "destroy",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} ",
                    "name": "return",
                    "type": "net.Socket"
                  },
                  "params": [
                    {
                      "name": "exception",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "exception",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Ensures that no more I/O activity happens on this socket. Only necessary in\ncase of errors (parse error or so).</p>\n<p>If <code>exception</code> is specified, an <a href=\"#net_event_error_1\"><code>&#39;error&#39;</code></a> event will be emitted and any\nlisteners for that event will receive <code>exception</code> as an argument.</p>\n"
            },
            {
              "textRaw": "socket.end([data][, encoding])",
              "type": "method",
              "name": "end",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The socket itself. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The socket itself."
                  },
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Half-closes the socket. i.e., it sends a FIN packet. It is possible the\nserver will still send some data.</p>\n<p>If <code>data</code> is specified, it is equivalent to calling\n<code>socket.write(data, encoding)</code> followed by <a href=\"#net_socket_end_data_encoding\"><code>socket.end()</code></a>.</p>\n"
            },
            {
              "textRaw": "socket.pause()",
              "type": "method",
              "name": "pause",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The socket itself. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The socket itself."
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Pauses the reading of data. That is, <a href=\"#net_event_data\"><code>&#39;data&#39;</code></a> events will not be emitted.\nUseful to throttle back an upload.</p>\n"
            },
            {
              "textRaw": "socket.ref()",
              "type": "method",
              "name": "ref",
              "meta": {
                "added": [
                  "v0.9.1"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The socket itself. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The socket itself."
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Opposite of <code>unref</code>, calling <code>ref</code> on a previously <code>unref</code>d socket will <em>not</em>\nlet the program exit if it&#39;s the only socket left (the default behavior). If\nthe socket is <code>ref</code>d calling <code>ref</code> again will have no effect.</p>\n"
            },
            {
              "textRaw": "socket.resume()",
              "type": "method",
              "name": "resume",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The socket itself. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The socket itself."
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Resumes reading after a call to <a href=\"#net_socket_pause\"><code>socket.pause()</code></a>.</p>\n"
            },
            {
              "textRaw": "socket.setEncoding([encoding])",
              "type": "method",
              "name": "setEncoding",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The socket itself. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The socket itself."
                  },
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Set the encoding for the socket as a <a href=\"stream.html#stream_class_stream_readable\">Readable Stream</a>. See\n<a href=\"stream.html#stream_readable_setencoding_encoding\"><code>stream.setEncoding()</code></a> for more information.</p>\n"
            },
            {
              "textRaw": "socket.setKeepAlive([enable][, initialDelay])",
              "type": "method",
              "name": "setKeepAlive",
              "meta": {
                "added": [
                  "v0.1.92"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The socket itself. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The socket itself."
                  },
                  "params": [
                    {
                      "name": "enable",
                      "optional": true
                    },
                    {
                      "name": "initialDelay",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "enable",
                      "optional": true
                    },
                    {
                      "name": "initialDelay",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n<code>enable</code> defaults to <code>false</code>.</p>\n<p>Set <code>initialDelay</code> (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting 0 for\ninitialDelay will leave the value unchanged from the default\n(or previous) setting. Defaults to <code>0</code>.</p>\n"
            },
            {
              "textRaw": "socket.setNoDelay([noDelay])",
              "type": "method",
              "name": "setNoDelay",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The socket itself. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The socket itself."
                  },
                  "params": [
                    {
                      "name": "noDelay",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "noDelay",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Disables the Nagle algorithm. By default TCP connections use the Nagle\nalgorithm, they buffer data before sending it off. Setting <code>true</code> for\n<code>noDelay</code> will immediately fire off data each time <code>socket.write()</code> is called.\n<code>noDelay</code> defaults to <code>true</code>.</p>\n"
            },
            {
              "textRaw": "socket.setTimeout(timeout[, callback])",
              "type": "method",
              "name": "setTimeout",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The socket itself. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The socket itself."
                  },
                  "params": [
                    {
                      "name": "timeout"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "timeout"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Sets the socket to timeout after <code>timeout</code> milliseconds of inactivity on\nthe socket. By default <code>net.Socket</code> do not have a timeout.</p>\n<p>When an idle timeout is triggered the socket will receive a <a href=\"#net_event_timeout\"><code>&#39;timeout&#39;</code></a>\nevent but the connection will not be severed. The user must manually call\n<a href=\"#net_socket_end_data_encoding\"><code>socket.end()</code></a> or <a href=\"#net_socket_destroy_exception\"><code>socket.destroy()</code></a> to end the connection.</p>\n<pre><code class=\"lang-js\">socket.setTimeout(3000);\nsocket.on(&#39;timeout&#39;, () =&gt; {\n  console.log(&#39;socket timeout&#39;);\n  socket.end();\n});\n</code></pre>\n<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.</p>\n<p>The optional <code>callback</code> parameter will be added as a one time listener for the\n<a href=\"#net_event_timeout\"><code>&#39;timeout&#39;</code></a> event.</p>\n"
            },
            {
              "textRaw": "socket.unref()",
              "type": "method",
              "name": "unref",
              "meta": {
                "added": [
                  "v0.9.1"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The socket itself. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The socket itself."
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Calling <code>unref</code> on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already <code>unref</code>d calling\n<code>unref</code> again will have no effect.</p>\n"
            },
            {
              "textRaw": "socket.write(data[, encoding][, callback])",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Sends data on the socket. The second parameter specifies the encoding in the\ncase of a string--it defaults to UTF8 encoding.</p>\n<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel\nbuffer. Returns <code>false</code> if all or part of the data was queued in user memory.\n<a href=\"#net_event_drain\"><code>&#39;drain&#39;</code></a> will be emitted when the buffer is again free.</p>\n<p>The optional <code>callback</code> parameter will be executed when the data is finally\nwritten out - this may not be immediately.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>Emitted once the socket is fully closed. The argument <code>had_error</code> is a boolean\nwhich says if the socket was closed due to a transmission error.</p>\n"
            },
            {
              "textRaw": "Event: 'connect'",
              "type": "event",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Emitted when a socket connection is successfully established.\nSee <a href=\"#net_net_createconnection\"><code>net.createConnection()</code></a>.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'data'",
              "type": "event",
              "name": "data",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>Emitted when data is received.  The argument <code>data</code> will be a <code>Buffer</code> or\n<code>String</code>.  Encoding of data is set by <code>socket.setEncoding()</code>.\n(See the <a href=\"stream.html#stream_class_stream_readable\">Readable Stream</a> section for more information.)</p>\n<p>Note that the <strong>data will be lost</strong> if there is no listener when a <code>Socket</code>\nemits a <code>&#39;data&#39;</code> event.</p>\n"
            },
            {
              "textRaw": "Event: 'drain'",
              "type": "event",
              "name": "drain",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.</p>\n<p>See also: the return values of <code>socket.write()</code></p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'end'",
              "type": "event",
              "name": "end",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Emitted when the other end of the socket sends a FIN packet, thus ending the\nreadable side of the socket.</p>\n<p>By default (<code>allowHalfOpen</code> is <code>false</code>) the socket will send a FIN packet\nback and destroy its file descriptor once it has written out its pending\nwrite queue. However, if <code>allowHalfOpen</code> is set to <code>true</code>, the socket will\nnot automatically <a href=\"#net_socket_end_data_encoding\"><code>end()</code></a> its writable side, allowing the\nuser to write arbitrary amounts of data. The user must call\n<a href=\"#net_socket_end_data_encoding\"><code>end()</code></a> explicitly to close the connection (i.e. sending a\nFIN packet back).</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>Emitted when an error occurs.  The <code>&#39;close&#39;</code> event will be called directly\nfollowing this event.</p>\n"
            },
            {
              "textRaw": "Event: 'lookup'",
              "type": "event",
              "name": "lookup",
              "meta": {
                "added": [
                  "v0.11.3"
                ],
                "changes": [
                  {
                    "version": "v5.10.0",
                    "pr-url": "https://github.com/nodejs/node/pull/5598",
                    "description": "The `host` parameter is supported now."
                  }
                ]
              },
              "desc": "<p>Emitted after resolving the hostname but before connecting.\nNot applicable to UNIX sockets.</p>\n<ul>\n<li><code>err</code> {Error|null} The error object.  See <a href=\"dns.html#dns_dns_lookup_hostname_options_callback\"><code>dns.lookup()</code></a>.</li>\n<li><code>address</code> {string} The IP address.</li>\n<li><code>family</code> {string|null} The address type.  See <a href=\"dns.html#dns_dns_lookup_hostname_options_callback\"><code>dns.lookup()</code></a>.</li>\n<li><code>host</code> {string} The hostname.</li>\n</ul>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'timeout'",
              "type": "event",
              "name": "timeout",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Emitted if the socket times out from inactivity. This is only to notify that\nthe socket has been idle. The user must manually close the connection.</p>\n<p>See also: <a href=\"#net_socket_settimeout_timeout_callback\"><code>socket.setTimeout()</code></a></p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "socket.bufferSize",
              "name": "bufferSize",
              "meta": {
                "added": [
                  "v0.3.8"
                ],
                "changes": []
              },
              "desc": "<p><code>net.Socket</code> has the property that <code>socket.write()</code> always works. This is to\nhelp users get up and running quickly. The computer cannot always keep up\nwith the amount of data that is written to a socket - the network connection\nsimply might be too slow. Node.js will internally queue up the data written to a\nsocket and send it out over the wire when it is possible. (Internally it is\npolling on the socket&#39;s file descriptor for being writable).</p>\n<p>The consequence of this internal buffering is that memory may grow. This\nproperty shows the number of characters currently buffered to be written.\n(Number of characters is approximately equal to the number of bytes to be\nwritten, but the buffer may contain strings, and the strings are lazily\nencoded, so the exact number of bytes is not known.)</p>\n<p>Users who experience large or growing <code>bufferSize</code> should attempt to\n&quot;throttle&quot; the data flows in their program with\n<a href=\"#net_socket_pause\"><code>socket.pause()</code></a> and <a href=\"#net_socket_resume\"><code>socket.resume()</code></a>.</p>\n"
            },
            {
              "textRaw": "socket.bytesRead",
              "name": "bytesRead",
              "meta": {
                "added": [
                  "v0.5.3"
                ],
                "changes": []
              },
              "desc": "<p>The amount of received bytes.</p>\n"
            },
            {
              "textRaw": "socket.bytesWritten",
              "name": "bytesWritten",
              "meta": {
                "added": [
                  "v0.5.3"
                ],
                "changes": []
              },
              "desc": "<p>The amount of bytes sent.</p>\n"
            },
            {
              "textRaw": "socket.connecting",
              "name": "connecting",
              "meta": {
                "added": [
                  "v6.1.0"
                ],
                "changes": []
              },
              "desc": "<p>If <code>true</code> -\n<a href=\"#net_socket_connect_options_connectlistener\"><code>socket.connect(options[, connectListener])</code></a>\nwas called and haven&#39;t yet finished. Will be set to <code>false</code> before emitting\n<code>connect</code> event and/or calling\n<a href=\"#net_socket_connect_options_connectlistener\"><code>socket.connect(options[, connectListener])</code></a>&#39;s\ncallback.</p>\n"
            },
            {
              "textRaw": "socket.destroyed",
              "name": "destroyed",
              "desc": "<p>A Boolean value that indicates if the connection is destroyed or not. Once a\nconnection is destroyed no further data can be transferred using it.</p>\n"
            },
            {
              "textRaw": "socket.localAddress",
              "name": "localAddress",
              "meta": {
                "added": [
                  "v0.9.6"
                ],
                "changes": []
              },
              "desc": "<p>The string representation of the local IP address the remote client is\nconnecting on. For example, in a server listening on <code>&#39;0.0.0.0&#39;</code>, if a client\nconnects on <code>&#39;192.168.1.1&#39;</code>, the value of <code>socket.localAddress</code> would be\n<code>&#39;192.168.1.1&#39;</code>.</p>\n"
            },
            {
              "textRaw": "socket.localPort",
              "name": "localPort",
              "meta": {
                "added": [
                  "v0.9.6"
                ],
                "changes": []
              },
              "desc": "<p>The numeric representation of the local port. For example,\n<code>80</code> or <code>21</code>.</p>\n"
            },
            {
              "textRaw": "socket.remoteAddress",
              "name": "remoteAddress",
              "meta": {
                "added": [
                  "v0.5.10"
                ],
                "changes": []
              },
              "desc": "<p>The string representation of the remote IP address. For example,\n<code>&#39;74.125.127.100&#39;</code> or <code>&#39;2001:4860:a005::68&#39;</code>. Value may be <code>undefined</code> if\nthe socket is destroyed (for example, if the client disconnected).</p>\n"
            },
            {
              "textRaw": "socket.remoteFamily",
              "name": "remoteFamily",
              "meta": {
                "added": [
                  "v0.11.14"
                ],
                "changes": []
              },
              "desc": "<p>The string representation of the remote IP family. <code>&#39;IPv4&#39;</code> or <code>&#39;IPv6&#39;</code>.</p>\n"
            },
            {
              "textRaw": "socket.remotePort",
              "name": "remotePort",
              "meta": {
                "added": [
                  "v0.5.10"
                ],
                "changes": []
              },
              "desc": "<p>The numeric representation of the remote port. For example,\n<code>80</code> or <code>21</code>.</p>\n"
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "new net.Server([options][, connectionListener])",
          "type": "method",
          "name": "Server",
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {net.Server} ",
                "name": "return",
                "type": "net.Server"
              },
              "params": [
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<p>See <a href=\"#net_net_createserver_options_connectionlistener\"><code>net.createServer([options][, connectionListener])</code></a>.</p>\n<p><code>net.Server</code> is an <a href=\"events.html#events_class_eventemitter\"><code>EventEmitter</code></a> with the following events:</p>\n",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": []
              },
              "desc": "<p>Emitted when the server closes. Note that if connections exist, this\nevent is not emitted until all connections are ended.</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connection'",
              "type": "event",
              "name": "connection",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>Emitted when a new connection is made. <code>socket</code> is an instance of\n<code>net.Socket</code>.</p>\n"
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "params": [],
              "desc": "<p>Emitted when an error occurs. Unlike <a href=\"#net_class_net_socket\"><code>net.Socket</code></a>, the <a href=\"#net_event_close\"><code>&#39;close&#39;</code></a>\nevent will <strong>not</strong> be emitted directly following this event unless\n<a href=\"#net_server_close_callback\"><code>server.close()</code></a> is manually called. See the example in discussion of\n<a href=\"#net_server_listen\"><code>server.listen()</code></a>.</p>\n"
            },
            {
              "textRaw": "Event: 'listening'",
              "type": "event",
              "name": "listening",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Emitted when the server has been bound after calling <a href=\"#net_server_listen\"><code>server.listen()</code></a>.</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "server.address()",
              "type": "method",
              "name": "address",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Returns the bound address, the address family name, and port of the server\nas reported by the operating system if listening on an IP socket.\nUseful to find which port was assigned when getting an OS-assigned address.\nReturns an object with <code>port</code>, <code>family</code>, and <code>address</code> properties:\n<code>{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code></p>\n<p>For a server listening on a pipe or UNIX domain socket, the name is returned\nas a string.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const server = net.createServer((socket) =&gt; {\n  socket.end(&#39;goodbye\\n&#39;);\n}).on(&#39;error&#39;, (err) =&gt; {\n  // handle errors here\n  throw err;\n});\n\n// grab an arbitrary unused port.\nserver.listen(() =&gt; {\n  console.log(&#39;opened server on&#39;, server.address());\n});\n</code></pre>\n<p>Don&#39;t call <code>server.address()</code> until the <code>&#39;listening&#39;</code> event has been emitted.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "server.close([callback])",
              "type": "method",
              "name": "close",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Server} ",
                    "name": "return",
                    "type": "net.Server"
                  },
                  "params": [
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Stops the server from accepting new connections and keeps existing\nconnections. This function is asynchronous, the server is finally\nclosed when all connections are ended and the server emits a <a href=\"#net_event_close\"><code>&#39;close&#39;</code></a> event.\nThe optional <code>callback</code> will be called once the <code>&#39;close&#39;</code> event occurs. Unlike\nthat event, it will be called with an Error as its only argument if the server\nwas not open when it was closed.</p>\n<p>Returns <code>server</code>.</p>\n"
            },
            {
              "textRaw": "server.getConnections(callback)",
              "type": "method",
              "name": "getConnections",
              "meta": {
                "added": [
                  "v0.9.7"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns {net.Server} ",
                    "name": "return",
                    "type": "net.Server"
                  },
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>Asynchronously get the number of concurrent connections on the server. Works\nwhen sockets were sent to forks.</p>\n<p>Callback should take two arguments <code>err</code> and <code>count</code>.</p>\n"
            },
            {
              "textRaw": "server.listen()",
              "type": "method",
              "name": "listen",
              "desc": "<p>Start a server listening for connections. A <code>net.Server</code> can be a TCP or\na <a href=\"#net_ipc_support\">IPC</a> server depending on what it listens to.</p>\n<p>Possible signatures:</p>\n<ul>\n<li><a href=\"#net_server_listen_handle_backlog_callback\"><code>server.listen(handle[, backlog][, callback])</code></a></li>\n<li><a href=\"#net_server_listen_options_callback\"><code>server.listen(options[, callback])</code></a></li>\n<li><a href=\"#net_server_listen_path_backlog_callback\"><code>server.listen(path[, backlog][, callback])</code></a>\nfor <a href=\"#net_ipc_support\">IPC</a> servers</li>\n<li><a href=\"#net_server_listen_port_host_backlog_callback\"><code>server.listen([port][, host][, backlog][, callback])</code></a>\nfor TCP servers</li>\n</ul>\n<p>This function is asynchronous.  When the server starts listening, the\n<a href=\"#net_event_listening\"><code>&#39;listening&#39;</code></a> event will be emitted.  The last parameter <code>callback</code>\nwill be added as a listener for the <a href=\"#net_event_listening\"><code>&#39;listening&#39;</code></a> event.</p>\n<p>All <code>listen()</code> methods can take a <code>backlog</code> parameter to specify the maximum\nlength of the queue of pending connections. The actual length will be determined\nby the OS through sysctl settings such as <code>tcp_max_syn_backlog</code> and <code>somaxconn</code>\non Linux. The default value of this parameter is 511 (not 512).</p>\n<p><em>Note</em>:</p>\n<ul>\n<li><p>All <a href=\"#net_class_net_socket\"><code>net.Socket</code></a> are set to <code>SO_REUSEADDR</code> (See <a href=\"http://man7.org/linux/man-pages/man7/socket.7.html\">socket(7)</a> for\ndetails).</p>\n</li>\n<li><p>The <code>server.listen()</code> method may be called multiple times. Each\nsubsequent call will <em>re-open</em> the server using the provided options.</p>\n</li>\n</ul>\n<p>One of the most common errors raised when listening is <code>EADDRINUSE</code>.\nThis happens when another server is already listening on the requested\n<code>port</code> / <code>path</code> / <code>handle</code>. One way to handle this would be to retry\nafter a certain amount of time:</p>\n<pre><code class=\"lang-js\">server.on(&#39;error&#39;, (e) =&gt; {\n  if (e.code === &#39;EADDRINUSE&#39;) {\n    console.log(&#39;Address in use, retrying...&#39;);\n    setTimeout(() =&gt; {\n      server.close();\n      server.listen(PORT, HOST);\n    }, 1000);\n  }\n});\n</code></pre>\n",
              "methods": [
                {
                  "textRaw": "server.listen(handle[, backlog][, callback])",
                  "type": "method",
                  "name": "listen",
                  "meta": {
                    "added": [
                      "v0.5.10"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {net.Server} ",
                        "name": "return",
                        "type": "net.Server"
                      },
                      "params": [
                        {
                          "textRaw": "`handle` {Object} ",
                          "name": "handle",
                          "type": "Object"
                        },
                        {
                          "textRaw": "`backlog` {number} Common parameter of [`server.listen()`][] functions ",
                          "name": "backlog",
                          "type": "number",
                          "desc": "Common parameter of [`server.listen()`][] functions",
                          "optional": true
                        },
                        {
                          "textRaw": "`callback` {Function} Common parameter of [`server.listen()`][] functions ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "Common parameter of [`server.listen()`][] functions",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "handle"
                        },
                        {
                          "name": "backlog",
                          "optional": true
                        },
                        {
                          "name": "callback",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Start a server listening for connections on a given <code>handle</code> that has\nalready been bound to a port, a UNIX domain socket, or a Windows named pipe.</p>\n<p>The <code>handle</code> object can be either a server, a socket (anything with an\nunderlying <code>_handle</code> member), or an object with an <code>fd</code> member that is a\nvalid file descriptor.</p>\n<p><em>Note</em>: Listening on a file descriptor is not supported on Windows.</p>\n"
                },
                {
                  "textRaw": "server.listen(options[, callback])",
                  "type": "method",
                  "name": "listen",
                  "meta": {
                    "added": [
                      "v0.11.14"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {net.Server} ",
                        "name": "return",
                        "type": "net.Server"
                      },
                      "params": [
                        {
                          "textRaw": "`options` {Object} Required. Supports the following properties: ",
                          "options": [
                            {
                              "textRaw": "`port` {number} ",
                              "name": "port",
                              "type": "number"
                            },
                            {
                              "textRaw": "`host` {string} ",
                              "name": "host",
                              "type": "string"
                            },
                            {
                              "textRaw": "`path` {string} Will be ignored if `port` is specified. See [Identifying paths for IPC connections][]. ",
                              "name": "path",
                              "type": "string",
                              "desc": "Will be ignored if `port` is specified. See [Identifying paths for IPC connections][]."
                            },
                            {
                              "textRaw": "`backlog` {number} Common parameter of [`server.listen()`][] functions ",
                              "name": "backlog",
                              "type": "number",
                              "desc": "Common parameter of [`server.listen()`][] functions"
                            },
                            {
                              "textRaw": "`exclusive` {boolean} Default to `false` ",
                              "name": "exclusive",
                              "type": "boolean",
                              "desc": "Default to `false`"
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "Required. Supports the following properties:"
                        },
                        {
                          "textRaw": "`callback` {Function} Common parameter of [`server.listen()`][] functions ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "Common parameter of [`server.listen()`][] functions",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options"
                        },
                        {
                          "name": "callback",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>If <code>port</code> is specified, it behaves the same as\n<a href=\"#net_server_listen_port_host_backlog_callback\"><code>server.listen([port][, hostname][, backlog][, callback])</code></a>.\nOtherwise, if <code>path</code> is specified, it behaves the same as\n<a href=\"#net_server_listen_path_backlog_callback\"><code>server.listen(path[, backlog][, callback])</code></a>.\nIf none of them is specified, an error will be thrown.</p>\n<p>If <code>exclusive</code> is <code>false</code> (default), then cluster workers will use the same\nunderlying handle, allowing connection handling duties to be shared. When\n<code>exclusive</code> is <code>true</code>, the handle is not shared, and attempted port sharing\nresults in an error. An example which listens on an exclusive port is\nshown below.</p>\n<pre><code class=\"lang-js\">server.listen({\n  host: &#39;localhost&#39;,\n  port: 80,\n  exclusive: true\n});\n</code></pre>\n"
                },
                {
                  "textRaw": "server.listen(path[, backlog][, callback])",
                  "type": "method",
                  "name": "listen",
                  "meta": {
                    "added": [
                      "v0.1.90"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {net.Server} ",
                        "name": "return",
                        "type": "net.Server"
                      },
                      "params": [
                        {
                          "textRaw": "`path` {String} Path the server should listen to. See [Identifying paths for IPC connections][]. ",
                          "name": "path",
                          "type": "String",
                          "desc": "Path the server should listen to. See [Identifying paths for IPC connections][]."
                        },
                        {
                          "textRaw": "`backlog` {number} Common parameter of [`server.listen()`][] functions ",
                          "name": "backlog",
                          "type": "number",
                          "desc": "Common parameter of [`server.listen()`][] functions",
                          "optional": true
                        },
                        {
                          "textRaw": "`callback` {Function} Common parameter of [`server.listen()`][] functions ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "Common parameter of [`server.listen()`][] functions",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "path"
                        },
                        {
                          "name": "backlog",
                          "optional": true
                        },
                        {
                          "name": "callback",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Start a <a href=\"#net_ipc_support\">IPC</a> server listening for connections on the given <code>path</code>.</p>\n"
                },
                {
                  "textRaw": "server.listen([port][, host][, backlog][, callback])",
                  "type": "method",
                  "name": "listen",
                  "meta": {
                    "added": [
                      "v0.1.90"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {net.Server} ",
                        "name": "return",
                        "type": "net.Server"
                      },
                      "params": [
                        {
                          "textRaw": "`port` {number} ",
                          "name": "port",
                          "type": "number",
                          "optional": true
                        },
                        {
                          "textRaw": "`host` {string} ",
                          "name": "host",
                          "type": "string",
                          "optional": true
                        },
                        {
                          "textRaw": "`backlog` {number} Common parameter of [`server.listen()`][] functions ",
                          "name": "backlog",
                          "type": "number",
                          "desc": "Common parameter of [`server.listen()`][] functions",
                          "optional": true
                        },
                        {
                          "textRaw": "`callback` {Function} Common parameter of [`server.listen()`][] functions ",
                          "name": "callback",
                          "type": "Function",
                          "desc": "Common parameter of [`server.listen()`][] functions",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "port",
                          "optional": true
                        },
                        {
                          "name": "host",
                          "optional": true
                        },
                        {
                          "name": "backlog",
                          "optional": true
                        },
                        {
                          "name": "callback",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Start a TCP server listening for connections on the given <code>port</code> and <code>host</code>.</p>\n<p>If <code>port</code> is omitted or is 0, the operating system will assign an arbitrary\nunused port, which can be retrieved by using <code>server.address().port</code>\nafter the <a href=\"#net_event_listening\"><code>&#39;listening&#39;</code></a> event has been emitted.</p>\n<p>If <code>host</code> is omitted, the server will accept connections on the\n<a href=\"https://en.wikipedia.org/wiki/IPv6_address#Unspecified_address\">unspecified IPv6 address</a> (<code>::</code>) when IPv6 is available, or the\n<a href=\"https://en.wikipedia.org/wiki/0.0.0.0\">unspecified IPv4 address</a> (<code>0.0.0.0</code>) otherwise.</p>\n<p><em>Note</em>: In most operating systems, listening to the\n<a href=\"https://en.wikipedia.org/wiki/IPv6_address#Unspecified_address\">unspecified IPv6 address</a> (<code>::</code>) may cause the <code>net.Server</code> to also listen on\nthe <a href=\"https://en.wikipedia.org/wiki/0.0.0.0\">unspecified IPv4 address</a> (<code>0.0.0.0</code>).</p>\n"
                }
              ],
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "server.ref()",
              "type": "method",
              "name": "ref",
              "meta": {
                "added": [
                  "v0.9.1"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Server} ",
                    "name": "return",
                    "type": "net.Server"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Opposite of <code>unref</code>, calling <code>ref</code> on a previously <code>unref</code>d server will <em>not</em>\nlet the program exit if it&#39;s the only server left (the default behavior). If\nthe server is <code>ref</code>d calling <code>ref</code> again will have no effect.</p>\n"
            },
            {
              "textRaw": "server.unref()",
              "type": "method",
              "name": "unref",
              "meta": {
                "added": [
                  "v0.9.1"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Server} ",
                    "name": "return",
                    "type": "net.Server"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Calling <code>unref</code> on a server will allow the program to exit if this is the only\nactive server in the event system. If the server is already <code>unref</code>d calling\n<code>unref</code> again will have no effect.</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "server.connections",
              "name": "connections",
              "meta": {
                "added": [
                  "v0.2.0"
                ],
                "deprecated": [
                  "v0.9.7"
                ],
                "changes": []
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`server.getConnections()`][] instead.",
              "desc": "<p>The number of concurrent connections on the server.</p>\n<p>This becomes <code>null</code> when sending a socket to a child with\n<a href=\"child_process.html#child_process_child_process_fork_modulepath_args_options\"><code>child_process.fork()</code></a>. To poll forks and get current number of active\nconnections use asynchronous <a href=\"#net_server_getconnections_callback\"><code>server.getConnections()</code></a> instead.</p>\n"
            },
            {
              "textRaw": "server.listening",
              "name": "listening",
              "meta": {
                "added": [
                  "v5.7.0"
                ],
                "changes": []
              },
              "desc": "<p>A Boolean indicating whether or not the server is listening for\nconnections.</p>\n"
            },
            {
              "textRaw": "server.maxConnections",
              "name": "maxConnections",
              "meta": {
                "added": [
                  "v0.2.0"
                ],
                "changes": []
              },
              "desc": "<p>Set this property to reject connections when the server&#39;s connection count gets\nhigh.</p>\n<p>It is not recommended to use this option once a socket has been sent to a child\nwith <a href=\"child_process.html#child_process_child_process_fork_modulepath_args_options\"><code>child_process.fork()</code></a>.</p>\n"
            }
          ]
        },
        {
          "textRaw": "net.connect()",
          "type": "method",
          "name": "connect",
          "desc": "<p>Aliases to\n<a href=\"#net_net_createconnection\"><code>net.createConnection()</code></a>.</p>\n<p>Possible signatures:</p>\n<ul>\n<li><a href=\"#net_net_connect_options_connectlistener\"><code>net.connect(options[, connectListener])</code></a></li>\n<li><a href=\"#net_net_connect_path_connectlistener\"><code>net.connect(path[, connectListener])</code></a> for <a href=\"#net_ipc_support\">IPC</a>\nconnections.</li>\n<li><a href=\"#net_net_connect_port_host_connectlistener\"><code>net.connect(port[, host][, connectListener])</code></a>\nfor TCP connections.</li>\n</ul>\n",
          "methods": [
            {
              "textRaw": "net.connect(options[, connectListener])",
              "type": "method",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.7.0"
                ],
                "changes": []
              },
              "desc": "<p>Alias to\n<a href=\"#net_net_createconnection_options_connectlistener\"><code>net.createConnection(options[, connectListener])</code></a>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options"
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "net.connect(path[, connectListener])",
              "type": "method",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Alias to\n<a href=\"#net_net_createconnection_path_connectlistener\"><code>net.createConnection(path[, connectListener])</code></a>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "net.connect(port[, host][, connectListener])",
              "type": "method",
              "name": "connect",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Alias to\n<a href=\"#net_net_createconnection_port_host_connectlistener\"><code>net.createConnection(port[, host][, connectListener])</code></a>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "net.createConnection()",
          "type": "method",
          "name": "createConnection",
          "desc": "<p>A factory function, which creates a new <a href=\"#net_class_net_socket\"><code>net.Socket</code></a>,\nimmediately initiates connection with <a href=\"#net_socket_connect\"><code>socket.connect()</code></a>,\nthen returns the <code>net.Socket</code> that starts the connection.</p>\n<p>When the connection is established, a <a href=\"#net_event_connect\"><code>&#39;connect&#39;</code></a> event will be emitted\non the returned socket. The last parameter <code>connectListener</code>, if supplied,\nwill be added as a listener for the <a href=\"#net_event_connect\"><code>&#39;connect&#39;</code></a> event <strong>once</strong>.</p>\n<p>Possible signatures:</p>\n<ul>\n<li><a href=\"#net_net_createconnection_options_connectlistener\"><code>net.createConnection(options[, connectListener])</code></a></li>\n<li><a href=\"#net_net_createconnection_path_connectlistener\"><code>net.createConnection(path[, connectListener])</code></a>\nfor <a href=\"#net_ipc_support\">IPC</a> connections.</li>\n<li><a href=\"#net_net_createconnection_port_host_connectlistener\"><code>net.createConnection(port[, host][, connectListener])</code></a>\nfor TCP connections.</li>\n</ul>\n<p><em>Note</em>: The <a href=\"#net_net_connect\"><code>net.connect()</code></a> function is an alias to this function.</p>\n",
          "methods": [
            {
              "textRaw": "net.createConnection(options[, connectListener])",
              "type": "method",
              "name": "createConnection",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The newly created socket used to start the connection. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The newly created socket used to start the connection."
                  },
                  "params": [
                    {
                      "textRaw": "`options` {Object} Required. Will be passed to both the [`new net.Socket([options])`][`new net.Socket(options)`] call and the [`socket.connect(options[, connectListener])`][`socket.connect(options)`] method. ",
                      "name": "options",
                      "type": "Object",
                      "desc": "Required. Will be passed to both the [`new net.Socket([options])`][`new net.Socket(options)`] call and the [`socket.connect(options[, connectListener])`][`socket.connect(options)`] method."
                    },
                    {
                      "textRaw": "`connectListener` {Function} Common parameter of the [`net.createConnection()`][] functions. If supplied, will be added as a listener for the [`'connect'`][] event on the returned socket once. ",
                      "name": "connectListener",
                      "type": "Function",
                      "desc": "Common parameter of the [`net.createConnection()`][] functions. If supplied, will be added as a listener for the [`'connect'`][] event on the returned socket once.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options"
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>For available options, see\n<a href=\"#net_new_net_socket_options\"><code>new net.Socket([options])</code></a>\nand <a href=\"#net_socket_connect_options_connectlistener\"><code>socket.connect(options[, connectListener])</code></a>.</p>\n<p>Additional options:</p>\n<ul>\n<li><code>timeout</code> {number} If set, will be used to call\n<a href=\"#net_socket_settimeout_timeout_callback\"><code>socket.setTimeout(timeout)</code></a> after the socket is created, but before\nit starts the connection.</li>\n</ul>\n<p>Following is an example of a client of the echo server described\nin the <a href=\"#net_net_createserver_options_connectionlistener\"><code>net.createServer()</code></a> section:</p>\n<pre><code class=\"lang-js\">const net = require(&#39;net&#39;);\nconst client = net.createConnection({ port: 8124 }, () =&gt; {\n  //&#39;connect&#39; listener\n  console.log(&#39;connected to server!&#39;);\n  client.write(&#39;world!\\r\\n&#39;);\n});\nclient.on(&#39;data&#39;, (data) =&gt; {\n  console.log(data.toString());\n  client.end();\n});\nclient.on(&#39;end&#39;, () =&gt; {\n  console.log(&#39;disconnected from server&#39;);\n});\n</code></pre>\n<p>To connect on the socket <code>/tmp/echo.sock</code> the second line would just be\nchanged to</p>\n<pre><code class=\"lang-js\">const client = net.createConnection({ path: &#39;/tmp/echo.sock&#39; });\n</code></pre>\n"
            },
            {
              "textRaw": "net.createConnection(path[, connectListener])",
              "type": "method",
              "name": "createConnection",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The newly created socket used to start the connection. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The newly created socket used to start the connection."
                  },
                  "params": [
                    {
                      "textRaw": "`path` {string} Path the socket should connect to. Will be passed to [`socket.connect(path[, connectListener])`][`socket.connect(path)`]. See [Identifying paths for IPC connections][]. ",
                      "name": "path",
                      "type": "string",
                      "desc": "Path the socket should connect to. Will be passed to [`socket.connect(path[, connectListener])`][`socket.connect(path)`]. See [Identifying paths for IPC connections][]."
                    },
                    {
                      "textRaw": "`connectListener` {Function} Common parameter of the [`net.createConnection()`][] functions, an \"once\" listener for the `'connect'` event on the initiating socket. Will be passed to [`socket.connect(path[, connectListener])`][`socket.connect(path)`]. ",
                      "name": "connectListener",
                      "type": "Function",
                      "desc": "Common parameter of the [`net.createConnection()`][] functions, an \"once\" listener for the `'connect'` event on the initiating socket. Will be passed to [`socket.connect(path[, connectListener])`][`socket.connect(path)`].",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Initiates an <a href=\"#net_ipc_support\">IPC</a> connection.</p>\n<p>This function creates a new <a href=\"#net_class_net_socket\"><code>net.Socket</code></a> with all options set to default,\nimmediately initiates connection with\n<a href=\"#net_socket_connect_path_connectlistener\"><code>socket.connect(path[, connectListener])</code></a>,\nthen returns the <code>net.Socket</code> that starts the connection.</p>\n"
            },
            {
              "textRaw": "net.createConnection(port[, host][, connectListener])",
              "type": "method",
              "name": "createConnection",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {net.Socket} The newly created socket used to start the connection. ",
                    "name": "return",
                    "type": "net.Socket",
                    "desc": "The newly created socket used to start the connection."
                  },
                  "params": [
                    {
                      "textRaw": "`port` {number} Port the socket should connect to. Will be passed to [`socket.connect(port[, host][, connectListener])`][`socket.connect(port, host)`]. ",
                      "name": "port",
                      "type": "number",
                      "desc": "Port the socket should connect to. Will be passed to [`socket.connect(port[, host][, connectListener])`][`socket.connect(port, host)`]."
                    },
                    {
                      "textRaw": "`host` {string} Host the socket should connect to. Defaults to `'localhost'`. Will be passed to [`socket.connect(port[, host][, connectListener])`][`socket.connect(port, host)`]. ",
                      "name": "host",
                      "type": "string",
                      "desc": "Host the socket should connect to. Defaults to `'localhost'`. Will be passed to [`socket.connect(port[, host][, connectListener])`][`socket.connect(port, host)`].",
                      "optional": true
                    },
                    {
                      "textRaw": "`connectListener` {Function} Common parameter of the [`net.createConnection()`][] functions, an \"once\" listener for the `'connect'` event on the initiating socket. Will be passed to [`socket.connect(path[, connectListener])`][`socket.connect(port, host)`]. ",
                      "name": "connectListener",
                      "type": "Function",
                      "desc": "Common parameter of the [`net.createConnection()`][] functions, an \"once\" listener for the `'connect'` event on the initiating socket. Will be passed to [`socket.connect(path[, connectListener])`][`socket.connect(port, host)`].",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Initiates a TCP connection.</p>\n<p>This function creates a new <a href=\"#net_class_net_socket\"><code>net.Socket</code></a> with all options set to default,\nimmediately initiates connection with\n<a href=\"#net_socket_connect_port_host_connectlistener\"><code>socket.connect(port[, host][, connectListener])</code></a>,\nthen returns the <code>net.Socket</code> that starts the connection.</p>\n"
            }
          ],
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "net.createServer([options][, connectionListener])",
          "type": "method",
          "name": "createServer",
          "meta": {
            "added": [
              "v0.5.0"
            ],
            "changes": []
          },
          "desc": "<p>Creates a new TCP or <a href=\"#net_ipc_support\">IPC</a> server.</p>\n<ul>\n<li><code>options</code> {Object}<ul>\n<li><code>allowHalfOpen</code> {boolean} Default to <code>false</code>. Indicates whether half-opened\nTCP connections are allowed.</li>\n<li><code>pauseOnConnect</code> {boolean} Default to <code>false</code>. Indicates whether the socket\nshould be paused on incoming connections.</li>\n</ul>\n</li>\n<li><code>connectionListener</code> {Function} Automatically set as a listener for the\n<a href=\"#net_event_connection\"><code>&#39;connection&#39;</code></a> event</li>\n<li>Returns: {net.Server}</li>\n</ul>\n<p>If <code>allowHalfOpen</code> is set to <code>true</code>, when the other end of the socket\nsends a FIN packet, the server will only send a FIN packet back when\n<a href=\"#net_socket_end_data_encoding\"><code>socket.end()</code></a> is explicitly called, until then the connection is\nhalf-closed (non-readable but still writable). See <a href=\"#net_event_end\"><code>&#39;end&#39;</code></a> event\nand <a href=\"https://tools.ietf.org/html/rfc1122#section-4.2.2.13\">RFC 1122</a> for more information.</p>\n<p>If <code>pauseOnConnect</code> is set to <code>true</code>, then the socket associated with each\nincoming connection will be paused, and no data will be read from its handle.\nThis allows connections to be passed between processes without any data being\nread by the original process. To begin reading data from a paused socket, call\n<a href=\"#net_socket_resume\"><code>socket.resume()</code></a>.</p>\n<p>The server can be a TCP server or a <a href=\"#net_ipc_support\">IPC</a> server, depending on what it\n<a href=\"#net_server_listen\"><code>listen()</code></a> to.</p>\n<p>Here is an example of an TCP echo server which listens for connections\non port 8124:</p>\n<pre><code class=\"lang-js\">const net = require(&#39;net&#39;);\nconst server = net.createServer((c) =&gt; {\n  // &#39;connection&#39; listener\n  console.log(&#39;client connected&#39;);\n  c.on(&#39;end&#39;, () =&gt; {\n    console.log(&#39;client disconnected&#39;);\n  });\n  c.write(&#39;hello\\r\\n&#39;);\n  c.pipe(c);\n});\nserver.on(&#39;error&#39;, (err) =&gt; {\n  throw err;\n});\nserver.listen(8124, () =&gt; {\n  console.log(&#39;server bound&#39;);\n});\n</code></pre>\n<p>Test this by using <code>telnet</code>:</p>\n<pre><code class=\"lang-console\">$ telnet localhost 8124\n</code></pre>\n<p>To listen on the socket <code>/tmp/echo.sock</code> the third line from the last would\njust be changed to</p>\n<pre><code class=\"lang-js\">server.listen(&#39;/tmp/echo.sock&#39;, () =&gt; {\n  console.log(&#39;server bound&#39;);\n});\n</code></pre>\n<p>Use <code>nc</code> to connect to a UNIX domain socket server:</p>\n<pre><code class=\"lang-console\">$ nc -U /tmp/echo.sock\n</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIP(input)",
          "type": "method",
          "name": "isIP",
          "meta": {
            "added": [
              "v0.3.0"
            ],
            "changes": []
          },
          "desc": "<p>Tests if input is an IP address. Returns 0 for invalid strings,\nreturns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIPv4(input)",
          "type": "method",
          "name": "isIPv4",
          "meta": {
            "added": [
              "v0.3.0"
            ],
            "changes": []
          },
          "desc": "<p>Returns true if input is a version 4 IP address, otherwise returns false.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIPv6(input)",
          "type": "method",
          "name": "isIPv6",
          "meta": {
            "added": [
              "v0.3.0"
            ],
            "changes": []
          },
          "desc": "<p>Returns true if input is a version 6 IP address, otherwise returns false.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Net"
    }
  ]
}
